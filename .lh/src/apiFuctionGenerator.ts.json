{
    "sourceFile": "src/apiFuctionGenerator.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 34,
            "patches": [
                {
                    "date": 1750729996840,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1750731013503,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,38 @@\n+function inferType(value: any): string {\n+  const type = typeof value;\n+  if (type === \"string\") return \"string\";\n+  if (type === \"number\") return \"number\";\n+  if (type === \"boolean\") return \"boolean\";\n+  if (Array.isArray(value)) return `${inferType(value[0])}[]`;\n+  return \"any\";\n+}\n+\n+function generateTypeName(pathParts: string[], name: string): string {\n+  const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);\n+  const clean = (s: string) =>\n+    s.replace(/[^a-zA-Z0-9]/g, \" \")\n+      .split(/\\s+/)\n+      .map(capitalize)\n+      .join(\"\");\n+  const base = pathParts.join(\"-\") || name;\n+  return clean(base) + \"Params\";\n+}\n+\n+function toCamel(str: string): string {\n+  return str\n+    .replace(/[-_\\/\\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : \"\"))\n+    .replace(/^(.)/, (c) => c.toLowerCase());\n+}\n+\n+\n export function generateApiFunctions(apiSpec: any): string {\n   const lines: string[] = [];\n+  const typeNames = new Set<string>();\n \n   function traverse(items: any[]) {\n     for (const item of items) {\n       if (item.item) {\n-        // 중간 그룹일 경우 재귀\n         traverse(item.item);\n       } else if (item.request?.url?.path) {\n         const name = item.name;\n         const method = item.request.method;\n@@ -32,8 +59,9 @@\n           } else {\n             typeName = generateTypeName(url.split(\"/\"), name);\n             params = `params: ${typeName}`;\n             bodyArg = \"params\";\n+            typeNames.add(typeName);\n           }\n         } catch {\n           params = \"\";\n           bodyArg = \"\";\n@@ -57,30 +85,19 @@\n   }\n \n   traverse(apiSpec);\n \n-  return lines.join(\"\\n\\n\");\n-}\n+  // 기본 import 구문\n+  const importLines = [\n+    `import { callUserApi } from \"./callUserApi\";`,\n+    `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n+  ];\n \n-function inferType(val: any): string {\n-  const type = typeof val;\n-  if (type === \"string\") return \"string\";\n-  if (type === \"number\") return \"number\";\n-  if (type === \"boolean\") return \"boolean\";\n-  if (Array.isArray(val)) return `${inferType(val[0])}[]`;\n-  return \"any\";\n-}\n+  // 타입 import 구문\n+  if (typeNames.size > 0) {\n+    importLines.push(\n+      `import { ${Array.from(typeNames).join(\", \")} } from \"./userApi.types\";`\n+    );\n+  }\n \n-function toCamel(str: string): string {\n-  return str\n-    .replace(/[-_/](.)/g, (_, c) => c.toUpperCase())\n-    .replace(/[^a-zA-Z0-9]/g, \"\")\n-    .replace(/^([A-Z])/, (s) => s.toLowerCase());\n-}\n-\n-function generateTypeName(pathParts: string[], name: string): string {\n-  return pathParts.map(capitalize).join(\"\") + \"Params\";\n-}\n-\n-function capitalize(s: string) {\n-  return s.charAt(0).toUpperCase() + s.slice(1);\n-}\n+  return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1750731416877,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,107 @@\n+function inferType(value: any): string {\n+  const type = typeof value;\n+  if (type === \"string\") return \"string\";\n+  if (type === \"number\") return \"number\";\n+  if (type === \"boolean\") return \"boolean\";\n+  if (Array.isArray(value)) return `${inferType(value[0])}[]`;\n+  return \"any\";\n+}\n+\n+function generateTypeName(pathParts: string[], name: string): string {\n+  const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);\n+  const clean = (s: string) =>\n+    s.replace(/[^a-zA-Z0-9]/g, \" \")\n+      .split(/\\s+/)\n+      .map(capitalize)\n+      .join(\"\");\n+  const base = pathParts.join(\"-\") || name;\n+  return clean(base) + \"Params\";\n+}\n+\n+function toCamel(str: string): string {\n+  return str\n+    .replace(/[-_\\/\\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : \"\"))\n+    .replace(/^(.)/, (c) => c.toLowerCase());\n+}\n+\n+\n+export function generateApiFunctions(apiSpec: any): string {\n+  const lines: string[] = [];\n+  const typeNames = new Set<string>();\n+\n+  function traverse(items: any[], groupNames: string[] = []) {\n+    for (const item of items) {\n+      if (item.item) {\n+        // 그룹 주석 추가\n+        lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}\\n`);\n+        traverse(item.item, [...groupNames, item.name]);\n+      } else if (item.request?.url?.path) {\n+        const name = item.name;\n+        const method = item.request.method;\n+        const url = item.request.url.raw?.replace(\"{{baseUrl}}/\", \"\") ?? item.request.url.path.join(\"/\");\n+        const title = name;\n+        const hasToken = item.request.header?.some((h: any) => h.key.toLowerCase() === \"authorization\");\n+        const bodyRaw = item.request.body?.raw;\n+\n+        let params: string;\n+        let bodyArg: string;\n+        let typeName: string;\n+\n+        try {\n+          const parsedBody = JSON.parse(bodyRaw || \"{}\");\n+          const keys = Object.keys(parsedBody);\n+\n+          if (keys.length === 0) {\n+            params = \"\";\n+            bodyArg = \"\";\n+          } else if (keys.length === 1) {\n+            const k = keys[0];\n+            params = `${k}: ${inferType(parsedBody[k])}`;\n+            bodyArg = `{ ${k}: ${k} }`;\n+          } else {\n+            typeName = generateTypeName(url.split(\"/\"), name);\n+            params = `params: ${typeName}`;\n+            bodyArg = \"params\";\n+            typeNames.add(typeName);\n+          }\n+        } catch {\n+          params = \"\";\n+          bodyArg = \"\";\n+        }\n+\n+        const fnName = toCamel(url.split(\"/\").join(\"_\"));\n+\n+        // 함수별 주석 추가 (필요시)\n+        lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n+        lines.push(`\n+export async function ${fnName}(${params}) {\n+  return callUserApi({\n+    title: \"${title}\",\n+    url: buildProxyUrl(\"${url}\"),\n+    ${hasToken ? \"withToken: true,\" : \"\"}\n+    ${bodyArg ? `body: ${bodyArg},` : \"\"}\n+    isCallPageLoader: true,\n+  });\n+}\n+        `.trim());\n+      }\n+    }\n+  }\n+\n+  traverse(apiSpec, []);\n+\n+  // 기본 import 구문\n+  const importLines = [\n+    `import { callUserApi } from \"./callUserApi\";`,\n+    `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n+  ];\n+\n+  // 타입 import 구문\n+  if (typeNames.size > 0) {\n+    importLines.push(\n+      `import { ${Array.from(typeNames).join(\", \")} } from \"./userApi.types\";`\n+    );\n+  }\n+\n+  return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1750813187319,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,127 @@\n+function inferType(value: any): string {\n+  const type = typeof value;\n+  if (type === \"string\") return \"string\";\n+  if (type === \"number\") return \"number\";\n+  if (type === \"boolean\") return \"boolean\";\n+  if (Array.isArray(value)) return `${inferType(value[0])}[]`;\n+  return \"any\";\n+}\n+\n+function generateTypeName(pathParts: string[], name: string): string {\n+  const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);\n+  const clean = (s: string) =>\n+    s.replace(/[^a-zA-Z0-9]/g, \" \")\n+      .split(/\\s+/)\n+      .map(capitalize)\n+      .join(\"\");\n+  const base = pathParts.join(\"-\") || name;\n+  return clean(base) + \"Params\";\n+}\n+\n+function toCamel(str: string): string {\n+  return str\n+    .replace(/[-_\\/\\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : \"\"))\n+    .replace(/^(.)/, (c) => c.toLowerCase());\n+}\n+\n+function parseRawJsonWithComments(raw: string): Record<string, { value: any; optional: boolean }> {\n+  const result: Record<string, { value: any; optional: boolean }> = {};\n+  const lines = raw.split(\"\\n\");\n+\n+  for (const line of lines) {\n+    const match = line.match(/\"(.+?)\"\\s*:\\s*(.+?)(\\s*\\/\\/\\s*(.*))?$/);\n+    if (!match) continue;\n+\n+    const [, key, rawValue, , comment] = match;\n+    let value: any;\n+    try {\n+      value = JSON.parse(rawValue.endsWith(\",\") ? rawValue.slice(0, -1) : rawValue);\n+    } catch {\n+      value = rawValue.trim().replace(/,$/, \"\");\n+    }\n+\n+    const optional = comment?.trim() === \"?\";\n+    result[key] = { value, optional };\n+  }\n+\n+  return result;\n+}\n+\n+export function generateApiFunctions(apiSpec: any): string {\n+  const lines: string[] = [];\n+  const typeNames = new Set<string>();\n+\n+  function traverse(items: any[], groupNames: string[] = []) {\n+    for (const item of items) {\n+      if (item.item) {\n+        lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}\\n`);\n+        traverse(item.item, [...groupNames, item.name]);\n+      } else if (item.request?.url?.path) {\n+        const name = item.name;\n+        const method = item.request.method;\n+        const url = item.request.url.raw?.replace(\"{{baseUrl}}/\", \"\") ?? item.request.url.path.join(\"/\");\n+        const title = name;\n+        const hasToken = item.request.header?.some((h: any) => h.key.toLowerCase() === \"authorization\");\n+        const bodyRaw = item.request.body?.raw;\n+\n+        let params = \"\";\n+        let bodyArg = \"\";\n+        let typeName = \"\";\n+\n+        try {\n+          const parsed = parseRawJsonWithComments(bodyRaw || \"\");\n+          const keys = Object.keys(parsed);\n+\n+          if (keys.length === 0) {\n+            params = \"\";\n+            bodyArg = \"\";\n+          } else if (keys.length === 1) {\n+            const [k] = keys;\n+            const { value, optional } = parsed[k];\n+            const inferred = inferType(value);\n+            params = `${k}${optional ? \"?\" : \"\"}: ${inferred}${optional ? \" | null\" : \"\"}`;\n+            bodyArg = `{ ${k}: ${k} }`;\n+          } else {\n+            typeName = generateTypeName(url.split(\"/\"), name);\n+            params = `params: ${typeName}`;\n+            bodyArg = \"params\";\n+            typeNames.add(typeName);\n+          }\n+        } catch {\n+          params = \"\";\n+          bodyArg = \"\";\n+        }\n+\n+        const fnName = toCamel(url.split(\"/\").join(\"_\"));\n+\n+        lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n+        lines.push(`\n+export async function ${fnName}(${params}) {\n+  return callUserApi({\n+    title: \"${title}\",\n+    url: buildProxyUrl(\"${url}\"),\n+    ${hasToken ? \"withToken: true,\" : \"\"}\n+    ${bodyArg ? `body: ${bodyArg},` : \"\"}\n+    isCallPageLoader: true,\n+  });\n+}\n+        `.trim());\n+      }\n+    }\n+  }\n+\n+  traverse(apiSpec, []);\n+\n+  const importLines = [\n+    `import { callUserApi } from \"./callUserApi\";`,\n+    `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n+  ];\n+\n+  if (typeNames.size > 0) {\n+    importLines.push(\n+      `import { ${Array.from(typeNames).join(\", \")} } from \"./userApi.types\";`\n+    );\n+  }\n+\n+  return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n+}\n"
                },
                {
                    "date": 1750814317264,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,8 +50,14 @@\n export function generateApiFunctions(apiSpec: any): string {\n   const lines: string[] = [];\n   const typeNames = new Set<string>();\n \n+  const topGroupName = apiSpec.name || \"Api\";\n+  const match = topGroupName.match(/\\(([^)]+)\\)/); // 👤 유저 (User) → \"User\"\n+  const group = match?.[1] || \"Api\"; // fallback\n+  const lowerGroup = group.toLowerCase(); // user / dealer\n+  const upperGroup = group.charAt(0).toUpperCase() + group.slice(1); // User / Dealer\n+\n   function traverse(items: any[], groupNames: string[] = []) {\n     for (const item of items) {\n       if (item.item) {\n         lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}\\n`);\n@@ -96,9 +102,9 @@\n \n         lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n         lines.push(`\n export async function ${fnName}(${params}) {\n-  return callUserApi({\n+  return call${upperGroup}Api({\n     title: \"${title}\",\n     url: buildProxyUrl(\"${url}\"),\n     ${hasToken ? \"withToken: true,\" : \"\"}\n     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n@@ -109,18 +115,18 @@\n       }\n     }\n   }\n \n-  traverse(apiSpec, []);\n+  traverse(apiSpec.item, []);\n \n   const importLines = [\n-    `import { callUserApi } from \"./callUserApi\";`,\n+    `import { call${upperGroup}Api } from \"./call${upperGroup}Api\";`,\n     `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n   ];\n \n   if (typeNames.size > 0) {\n     importLines.push(\n-      `import { ${Array.from(typeNames).join(\", \")} } from \"./userApi.types\";`\n+      `import { ${Array.from(typeNames).join(\", \")} } from \"./${lowerGroup}Api.types\";`\n     );\n   }\n \n   return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n"
                },
                {
                    "date": 1750814382498,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,14 +50,8 @@\n export function generateApiFunctions(apiSpec: any): string {\n   const lines: string[] = [];\n   const typeNames = new Set<string>();\n \n-  const topGroupName = apiSpec.name || \"Api\";\n-  const match = topGroupName.match(/\\(([^)]+)\\)/); // 👤 유저 (User) → \"User\"\n-  const group = match?.[1] || \"Api\"; // fallback\n-  const lowerGroup = group.toLowerCase(); // user / dealer\n-  const upperGroup = group.charAt(0).toUpperCase() + group.slice(1); // User / Dealer\n-\n   function traverse(items: any[], groupNames: string[] = []) {\n     for (const item of items) {\n       if (item.item) {\n         lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}\\n`);\n@@ -102,113 +96,8 @@\n \n         lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n         lines.push(`\n export async function ${fnName}(${params}) {\n-  return call${upperGroup}Api({\n-    title: \"${title}\",\n-    url: buildProxyUrl(\"${url}\"),\n-    ${hasToken ? \"withToken: true,\" : \"\"}\n-    ${bodyArg ? `body: ${bodyArg},` : \"\"}\n-    isCallPageLoader: true,\n-  });\n-}\n-        `.trim());\n-      }\n-    }\n-  }\n-\n-  traverse(apiSpec.item, []);\n-\n-  const importLines = [\n-    `import { call${upperGroup}Api } from \"./call${upperGroup}Api\";`,\n-    `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n-  ];\n-\n-  if (typeNames.size > 0) {\n-    importLines.push(\n-      `import { ${Array.from(typeNames).join(\", \")} } from \"./${lowerGroup}Api.types\";`\n-    );\n-  }\n-\n-  return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n-}\n-function inferType(value: any): string {\n-  const type = typeof value;\n-  if (type === \"string\") return \"string\";\n-  if (type === \"number\") return \"number\";\n-  if (type === \"boolean\") return \"boolean\";\n-  if (Array.isArray(value)) return `${inferType(value[0])}[]`;\n-  return \"any\";\n-}\n-\n-function generateTypeName(pathParts: string[], name: string): string {\n-  const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);\n-  const clean = (s: string) =>\n-    s.replace(/[^a-zA-Z0-9]/g, \" \")\n-      .split(/\\s+/)\n-      .map(capitalize)\n-      .join(\"\");\n-  const base = pathParts.join(\"-\") || name;\n-  return clean(base) + \"Params\";\n-}\n-\n-function toCamel(str: string): string {\n-  return str\n-    .replace(/[-_\\/\\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : \"\"))\n-    .replace(/^(.)/, (c) => c.toLowerCase());\n-}\n-\n-\n-export function generateApiFunctions(apiSpec: any): string {\n-  const lines: string[] = [];\n-  const typeNames = new Set<string>();\n-\n-  function traverse(items: any[], groupNames: string[] = []) {\n-    for (const item of items) {\n-      if (item.item) {\n-        // 그룹 주석 추가\n-        lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}\\n`);\n-        traverse(item.item, [...groupNames, item.name]);\n-      } else if (item.request?.url?.path) {\n-        const name = item.name;\n-        const method = item.request.method;\n-        const url = item.request.url.raw?.replace(\"{{baseUrl}}/\", \"\") ?? item.request.url.path.join(\"/\");\n-        const title = name;\n-        const hasToken = item.request.header?.some((h: any) => h.key.toLowerCase() === \"authorization\");\n-        const bodyRaw = item.request.body?.raw;\n-\n-        let params: string;\n-        let bodyArg: string;\n-        let typeName: string;\n-\n-        try {\n-          const parsedBody = JSON.parse(bodyRaw || \"{}\");\n-          const keys = Object.keys(parsedBody);\n-\n-          if (keys.length === 0) {\n-            params = \"\";\n-            bodyArg = \"\";\n-          } else if (keys.length === 1) {\n-            const k = keys[0];\n-            params = `${k}: ${inferType(parsedBody[k])}`;\n-            bodyArg = `{ ${k}: ${k} }`;\n-          } else {\n-            typeName = generateTypeName(url.split(\"/\"), name);\n-            params = `params: ${typeName}`;\n-            bodyArg = \"params\";\n-            typeNames.add(typeName);\n-          }\n-        } catch {\n-          params = \"\";\n-          bodyArg = \"\";\n-        }\n-\n-        const fnName = toCamel(url.split(\"/\").join(\"_\"));\n-\n-        // 함수별 주석 추가 (필요시)\n-        lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n-        lines.push(`\n-export async function ${fnName}(${params}) {\n   return callUserApi({\n     title: \"${title}\",\n     url: buildProxyUrl(\"${url}\"),\n     ${hasToken ? \"withToken: true,\" : \"\"}\n@@ -222,122 +111,17 @@\n   }\n \n   traverse(apiSpec, []);\n \n-  // 기본 import 구문\n   const importLines = [\n     `import { callUserApi } from \"./callUserApi\";`,\n     `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n   ];\n \n-  // 타입 import 구문\n   if (typeNames.size > 0) {\n     importLines.push(\n       `import { ${Array.from(typeNames).join(\", \")} } from \"./userApi.types\";`\n     );\n   }\n \n   return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n }\n-function inferType(value: any): string {\n-  const type = typeof value;\n-  if (type === \"string\") return \"string\";\n-  if (type === \"number\") return \"number\";\n-  if (type === \"boolean\") return \"boolean\";\n-  if (Array.isArray(value)) return `${inferType(value[0])}[]`;\n-  return \"any\";\n-}\n-\n-function generateTypeName(pathParts: string[], name: string): string {\n-  const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);\n-  const clean = (s: string) =>\n-    s.replace(/[^a-zA-Z0-9]/g, \" \")\n-      .split(/\\s+/)\n-      .map(capitalize)\n-      .join(\"\");\n-  const base = pathParts.join(\"-\") || name;\n-  return clean(base) + \"Params\";\n-}\n-\n-function toCamel(str: string): string {\n-  return str\n-    .replace(/[-_\\/\\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : \"\"))\n-    .replace(/^(.)/, (c) => c.toLowerCase());\n-}\n-\n-\n-export function generateApiFunctions(apiSpec: any): string {\n-  const lines: string[] = [];\n-  const typeNames = new Set<string>();\n-\n-  function traverse(items: any[]) {\n-    for (const item of items) {\n-      if (item.item) {\n-        traverse(item.item);\n-      } else if (item.request?.url?.path) {\n-        const name = item.name;\n-        const method = item.request.method;\n-        const url = item.request.url.raw?.replace(\"{{baseUrl}}/\", \"\") ?? item.request.url.path.join(\"/\");\n-        const title = name;\n-        const hasToken = item.request.header?.some((h: any) => h.key.toLowerCase() === \"authorization\");\n-        const bodyRaw = item.request.body?.raw;\n-\n-        let params: string;\n-        let bodyArg: string;\n-        let typeName: string;\n-\n-        try {\n-          const parsedBody = JSON.parse(bodyRaw || \"{}\");\n-          const keys = Object.keys(parsedBody);\n-\n-          if (keys.length === 0) {\n-            params = \"\";\n-            bodyArg = \"\";\n-          } else if (keys.length === 1) {\n-            const k = keys[0];\n-            params = `${k}: ${inferType(parsedBody[k])}`;\n-            bodyArg = `{ ${k}: ${k} }`;\n-          } else {\n-            typeName = generateTypeName(url.split(\"/\"), name);\n-            params = `params: ${typeName}`;\n-            bodyArg = \"params\";\n-            typeNames.add(typeName);\n-          }\n-        } catch {\n-          params = \"\";\n-          bodyArg = \"\";\n-        }\n-\n-        const fnName = toCamel(url.split(\"/\").join(\"_\"));\n-\n-        lines.push(`\n-export async function ${fnName}(${params}) {\n-  return callUserApi({\n-    title: \"${title}\",\n-    url: buildProxyUrl(\"${url}\"),\n-    ${hasToken ? \"withToken: true,\" : \"\"}\n-    ${bodyArg ? `body: ${bodyArg},` : \"\"}\n-    isCallPageLoader: true,\n-  });\n-}\n-        `.trim());\n-      }\n-    }\n-  }\n-\n-  traverse(apiSpec);\n-\n-  // 기본 import 구문\n-  const importLines = [\n-    `import { callUserApi } from \"./callUserApi\";`,\n-    `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n-  ];\n-\n-  // 타입 import 구문\n-  if (typeNames.size > 0) {\n-    importLines.push(\n-      `import { ${Array.from(typeNames).join(\", \")} } from \"./userApi.types\";`\n-    );\n-  }\n-\n-  return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n-}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1750814451056,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,12 +50,21 @@\n export function generateApiFunctions(apiSpec: any): string {\n   const lines: string[] = [];\n   const typeNames = new Set<string>();\n \n+  if (!Array.isArray(apiSpec?.item)) {\n+    throw new Error(\"Invalid API spec: 'item' array missing.\");\n+  }\n+\n+  const groupMatch = apiSpec.name?.match(/\\(([^)]+)\\)/); // 👤 유저 (User)\n+  const groupName = groupMatch?.[1] || \"Api\";\n+  const upperGroup = groupName.charAt(0).toUpperCase() + groupName.slice(1); // Dealer\n+  const lowerGroup = upperGroup.toLowerCase(); // dealer\n+\n   function traverse(items: any[], groupNames: string[] = []) {\n     for (const item of items) {\n       if (item.item) {\n-        lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}\\n`);\n+        lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}`);\n         traverse(item.item, [...groupNames, item.name]);\n       } else if (item.request?.url?.path) {\n         const name = item.name;\n         const method = item.request.method;\n@@ -91,14 +100,14 @@\n           params = \"\";\n           bodyArg = \"\";\n         }\n \n-        const fnName = toCamel(url.split(\"/\").join(\"_\"));\n+        const fnName = toCamel(`${lowerGroup}_${url.split(\"/\").join(\"_\")}`);\n \n         lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n         lines.push(`\n export async function ${fnName}(${params}) {\n-  return callUserApi({\n+  return call${upperGroup}Api({\n     title: \"${title}\",\n     url: buildProxyUrl(\"${url}\"),\n     ${hasToken ? \"withToken: true,\" : \"\"}\n     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n@@ -109,18 +118,18 @@\n       }\n     }\n   }\n \n-  traverse(apiSpec, []);\n+  traverse(apiSpec.item, []);\n \n   const importLines = [\n-    `import { callUserApi } from \"./callUserApi\";`,\n+    `import { call${upperGroup}Api } from \"./call${upperGroup}Api\";`,\n     `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n   ];\n \n   if (typeNames.size > 0) {\n     importLines.push(\n-      `import { ${Array.from(typeNames).join(\", \")} } from \"./userApi.types\";`\n+      `import { ${Array.from(typeNames).join(\", \")} } from \"./${lowerGroup}Api.types\";`\n     );\n   }\n \n   return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n"
                },
                {
                    "date": 1750814521972,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,26 +45,36 @@\n   }\n \n   return result;\n }\n-\n export function generateApiFunctions(apiSpec: any): string {\n   const lines: string[] = [];\n   const typeNames = new Set<string>();\n \n-  if (!Array.isArray(apiSpec?.item)) {\n+  // 💡 여기서 item 배열이 없고, 전체가 배열이면 래핑\n+  const topLevel = Array.isArray(apiSpec)\n+    ? { name: \"UnnamedGroup\", item: apiSpec }\n+    : apiSpec;\n+\n+  if (!Array.isArray(topLevel.item)) {\n     throw new Error(\"Invalid API spec: 'item' array missing.\");\n   }\n \n-  const groupMatch = apiSpec.name?.match(/\\(([^)]+)\\)/); // 👤 유저 (User)\n-  const groupName = groupMatch?.[1] || \"Api\";\n-  const upperGroup = groupName.charAt(0).toUpperCase() + groupName.slice(1); // Dealer\n-  const lowerGroup = upperGroup.toLowerCase(); // dealer\n+  const groupType = extractGroupType(topLevel.name); // \"User\" or \"Dealer\"\n \n+  function extractGroupType(name: string): string {\n+    if (!name) return \"User\";\n+    const match = name.match(/\\((.*?)\\)/);\n+    return match ? match[1] : \"User\";\n+  }\n+\n+  const fnPrefix = groupType.toLowerCase(); // user, dealer\n+  const typeImport = `import { ${Array.from(typeNames).join(\", \")} } from \"./${fnPrefix}Api.types\";`;\n+\n   function traverse(items: any[], groupNames: string[] = []) {\n     for (const item of items) {\n       if (item.item) {\n-        lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}`);\n+        lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}\\n`);\n         traverse(item.item, [...groupNames, item.name]);\n       } else if (item.request?.url?.path) {\n         const name = item.name;\n         const method = item.request.method;\n@@ -100,14 +110,14 @@\n           params = \"\";\n           bodyArg = \"\";\n         }\n \n-        const fnName = toCamel(`${lowerGroup}_${url.split(\"/\").join(\"_\")}`);\n+        const fnName = toCamel(url.split(\"/\").join(\"_\"));\n \n         lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n         lines.push(`\n export async function ${fnName}(${params}) {\n-  return call${upperGroup}Api({\n+  return call${groupType}Api({\n     title: \"${title}\",\n     url: buildProxyUrl(\"${url}\"),\n     ${hasToken ? \"withToken: true,\" : \"\"}\n     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n@@ -118,19 +128,17 @@\n       }\n     }\n   }\n \n-  traverse(apiSpec.item, []);\n+  traverse(topLevel.item);\n \n   const importLines = [\n-    `import { call${upperGroup}Api } from \"./call${upperGroup}Api\";`,\n+    `import { call${groupType}Api } from \"./call${groupType}Api\";`,\n     `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n   ];\n \n   if (typeNames.size > 0) {\n-    importLines.push(\n-      `import { ${Array.from(typeNames).join(\", \")} } from \"./${lowerGroup}Api.types\";`\n-    );\n+    importLines.push(typeImport);\n   }\n \n   return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n }\n"
                },
                {
                    "date": 1750814651577,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,28 +49,25 @@\n export function generateApiFunctions(apiSpec: any): string {\n   const lines: string[] = [];\n   const typeNames = new Set<string>();\n \n-  // 💡 여기서 item 배열이 없고, 전체가 배열이면 래핑\n   const topLevel = Array.isArray(apiSpec)\n     ? { name: \"UnnamedGroup\", item: apiSpec }\n     : apiSpec;\n \n   if (!Array.isArray(topLevel.item)) {\n     throw new Error(\"Invalid API spec: 'item' array missing.\");\n   }\n \n-  const groupType = extractGroupType(topLevel.name); // \"User\" or \"Dealer\"\n+  const groupType = extractGroupType(topLevel.name); // e.g. \"Dealer\"\n+  const fnPrefix = groupType.toLowerCase();          // e.g. \"dealer\"\n \n   function extractGroupType(name: string): string {\n     if (!name) return \"User\";\n     const match = name.match(/\\((.*?)\\)/);\n     return match ? match[1] : \"User\";\n   }\n \n-  const fnPrefix = groupType.toLowerCase(); // user, dealer\n-  const typeImport = `import { ${Array.from(typeNames).join(\", \")} } from \"./${fnPrefix}Api.types\";`;\n-\n   function traverse(items: any[], groupNames: string[] = []) {\n     for (const item of items) {\n       if (item.item) {\n         lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}\\n`);\n@@ -110,9 +107,9 @@\n           params = \"\";\n           bodyArg = \"\";\n         }\n \n-        const fnName = toCamel(url.split(\"/\").join(\"_\"));\n+        const fnName = `${fnPrefix}${toCamel(url.split(\"/\").join(\"_\"))}`;\n \n         lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n         lines.push(`\n export async function ${fnName}(${params}) {\n@@ -136,9 +133,9 @@\n     `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n   ];\n \n   if (typeNames.size > 0) {\n-    importLines.push(typeImport);\n+    importLines.push(`import { ${Array.from(typeNames).join(\", \")} } from \"./${fnPrefix}Api.types\";`);\n   }\n \n   return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n }\n"
                },
                {
                    "date": 1750814746680,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,144 @@\n+function inferType(value: any): string {\n+  const type = typeof value;\n+  if (type === \"string\") return \"string\";\n+  if (type === \"number\") return \"number\";\n+  if (type === \"boolean\") return \"boolean\";\n+  if (Array.isArray(value)) return `${inferType(value[0])}[]`;\n+  return \"any\";\n+}\n+\n+function generateTypeName(pathParts: string[], name: string): string {\n+  const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);\n+  const clean = (s: string) =>\n+    s.replace(/[^a-zA-Z0-9]/g, \" \")\n+      .split(/\\s+/)\n+      .map(capitalize)\n+      .join(\"\");\n+  const base = pathParts.join(\"-\") || name;\n+  return clean(base) + \"Params\";\n+}\n+\n+function toCamel(str: string): string {\n+  return str\n+    .replace(/[-_\\/\\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : \"\"))\n+    .replace(/^(.)/, (c) => c.toLowerCase());\n+}\n+\n+function parseRawJsonWithComments(raw: string): Record<string, { value: any; optional: boolean }> {\n+  const result: Record<string, { value: any; optional: boolean }> = {};\n+  const lines = raw.split(\"\\n\");\n+\n+  for (const line of lines) {\n+    const match = line.match(/\"(.+?)\"\\s*:\\s*(.+?)(\\s*\\/\\/\\s*(.*))?$/);\n+    if (!match) continue;\n+\n+    const [, key, rawValue, , comment] = match;\n+    let value: any;\n+    try {\n+      value = JSON.parse(rawValue.endsWith(\",\") ? rawValue.slice(0, -1) : rawValue);\n+    } catch {\n+      value = rawValue.trim().replace(/,$/, \"\");\n+    }\n+\n+    const optional = comment?.trim() === \"?\";\n+    result[key] = { value, optional };\n+  }\n+\n+  return result;\n+}\n+export function generateApiFunctions(apiSpec: any): string {\n+  const lines: string[] = [];\n+  const typeNames = new Set<string>();\n+\n+  const topLevel = Array.isArray(apiSpec)\n+    ? { name: \"UnnamedGroup\", item: apiSpec }\n+    : apiSpec;\n+\n+  if (!Array.isArray(topLevel.item)) {\n+    throw new Error(\"Invalid API spec: 'item' array missing.\");\n+  }\n+\n+  // ✅ extract groupType AFTER topLevel.name is confirmed\n+  function extractGroupType(name: string): string {\n+    if (!name) return \"User\";\n+    const match = name.match(/\\((.*?)\\)/);\n+    return match ? match[1] : \"User\";\n+  }\n+\n+  const groupType = extractGroupType(topLevel.name); // ✅ 올바른 위치\n+  const fnPrefix = groupType.toLowerCase();          // \"dealer\"\n+  const apiCaller = `call${groupType}Api`;           // \"callDealerApi\"\n+\n+  function traverse(items: any[], groupNames: string[] = []) {\n+    for (const item of items) {\n+      if (item.item) {\n+        lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}\\n`);\n+        traverse(item.item, [...groupNames, item.name]);\n+      } else if (item.request?.url?.path) {\n+        const name = item.name;\n+        const url = item.request.url.raw?.replace(\"{{baseUrl}}/\", \"\") ?? item.request.url.path.join(\"/\");\n+        const hasToken = item.request.header?.some((h: any) => h.key.toLowerCase() === \"authorization\");\n+        const bodyRaw = item.request.body?.raw;\n+\n+        let params = \"\";\n+        let bodyArg = \"\";\n+        let typeName = \"\";\n+\n+        try {\n+          const parsed = parseRawJsonWithComments(bodyRaw || \"\");\n+          const keys = Object.keys(parsed);\n+\n+          if (keys.length === 0) {\n+            params = \"\";\n+            bodyArg = \"\";\n+          } else if (keys.length === 1) {\n+            const [k] = keys;\n+            const { value, optional } = parsed[k];\n+            const inferred = inferType(value);\n+            params = `${k}${optional ? \"?\" : \"\"}: ${inferred}${optional ? \" | null\" : \"\"}`;\n+            bodyArg = `{ ${k}: ${k} }`;\n+          } else {\n+            typeName = generateTypeName(url.split(\"/\"), name);\n+            params = `params: ${typeName}`;\n+            bodyArg = \"params\";\n+            typeNames.add(typeName);\n+          }\n+        } catch {\n+          params = \"\";\n+          bodyArg = \"\";\n+        }\n+\n+        const fnName = `${fnPrefix}${toCamel(url.split(\"/\").join(\"_\"))}`;\n+\n+        lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n+        lines.push(`\n+export async function ${fnName}(${params}) {\n+  return ${apiCaller}({\n+    title: \"${name}\",\n+    url: buildProxyUrl(\"${url}\"),\n+    ${hasToken ? \"withToken: true,\" : \"\"}\n+    ${bodyArg ? `body: ${bodyArg},` : \"\"}\n+    isCallPageLoader: true,\n+  });\n+}\n+        `.trim());\n+      }\n+    }\n+  }\n+\n+  traverse(topLevel.item);\n+\n+  const importLines = [\n+    `import { ${apiCaller} } from \"./${apiCaller}\";`,\n+    `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n+  ];\n+\n+  if (typeNames.size > 0) {\n+    importLines.push(\n+      `import { ${Array.from(typeNames).join(\", \")} } from \"./${fnPrefix}Api.types\";`\n+    );\n+  }\n+\n+  return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n+}\n+\n"
                },
                {
                    "date": 1750814850995,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,8 +45,9 @@\n   }\n \n   return result;\n }\n+\n export function generateApiFunctions(apiSpec: any): string {\n   const lines: string[] = [];\n   const typeNames = new Set<string>();\n \n@@ -57,18 +58,17 @@\n   if (!Array.isArray(topLevel.item)) {\n     throw new Error(\"Invalid API spec: 'item' array missing.\");\n   }\n \n-  // ✅ extract groupType AFTER topLevel.name is confirmed\n   function extractGroupType(name: string): string {\n     if (!name) return \"User\";\n     const match = name.match(/\\((.*?)\\)/);\n     return match ? match[1] : \"User\";\n   }\n \n-  const groupType = extractGroupType(topLevel.name); // ✅ 올바른 위치\n-  const fnPrefix = groupType.toLowerCase();          // \"dealer\"\n-  const apiCaller = `call${groupType}Api`;           // \"callDealerApi\"\n+  const groupType = extractGroupType(topLevel.name);\n+  const fnPrefix = groupType.toLowerCase();\n+  const apiCaller = `call${groupType}Api`;\n \n   function traverse(items: any[], groupNames: string[] = []) {\n     for (const item of items) {\n       if (item.item) {\n@@ -107,9 +107,9 @@\n           params = \"\";\n           bodyArg = \"\";\n         }\n \n-        const fnName = `${fnPrefix}${toCamel(url.split(\"/\").join(\"_\"))}`;\n+        const fnName = toCamel(`${fnPrefix}-${url.split(\"/\").join(\"-\")}`);\n \n         lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n         lines.push(`\n export async function ${fnName}(${params}) {\n@@ -140,146 +140,4 @@\n   }\n \n   return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n }\n-\n-function inferType(value: any): string {\n-  const type = typeof value;\n-  if (type === \"string\") return \"string\";\n-  if (type === \"number\") return \"number\";\n-  if (type === \"boolean\") return \"boolean\";\n-  if (Array.isArray(value)) return `${inferType(value[0])}[]`;\n-  return \"any\";\n-}\n-\n-function generateTypeName(pathParts: string[], name: string): string {\n-  const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);\n-  const clean = (s: string) =>\n-    s.replace(/[^a-zA-Z0-9]/g, \" \")\n-      .split(/\\s+/)\n-      .map(capitalize)\n-      .join(\"\");\n-  const base = pathParts.join(\"-\") || name;\n-  return clean(base) + \"Params\";\n-}\n-\n-function toCamel(str: string): string {\n-  return str\n-    .replace(/[-_\\/\\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : \"\"))\n-    .replace(/^(.)/, (c) => c.toLowerCase());\n-}\n-\n-function parseRawJsonWithComments(raw: string): Record<string, { value: any; optional: boolean }> {\n-  const result: Record<string, { value: any; optional: boolean }> = {};\n-  const lines = raw.split(\"\\n\");\n-\n-  for (const line of lines) {\n-    const match = line.match(/\"(.+?)\"\\s*:\\s*(.+?)(\\s*\\/\\/\\s*(.*))?$/);\n-    if (!match) continue;\n-\n-    const [, key, rawValue, , comment] = match;\n-    let value: any;\n-    try {\n-      value = JSON.parse(rawValue.endsWith(\",\") ? rawValue.slice(0, -1) : rawValue);\n-    } catch {\n-      value = rawValue.trim().replace(/,$/, \"\");\n-    }\n-\n-    const optional = comment?.trim() === \"?\";\n-    result[key] = { value, optional };\n-  }\n-\n-  return result;\n-}\n-export function generateApiFunctions(apiSpec: any): string {\n-  const lines: string[] = [];\n-  const typeNames = new Set<string>();\n-\n-  const topLevel = Array.isArray(apiSpec)\n-    ? { name: \"UnnamedGroup\", item: apiSpec }\n-    : apiSpec;\n-\n-  if (!Array.isArray(topLevel.item)) {\n-    throw new Error(\"Invalid API spec: 'item' array missing.\");\n-  }\n-\n-  const groupType = extractGroupType(topLevel.name); // e.g. \"Dealer\"\n-  const fnPrefix = groupType.toLowerCase();          // e.g. \"dealer\"\n-\n-  function extractGroupType(name: string): string {\n-    if (!name) return \"User\";\n-    const match = name.match(/\\((.*?)\\)/);\n-    return match ? match[1] : \"User\";\n-  }\n-\n-  function traverse(items: any[], groupNames: string[] = []) {\n-    for (const item of items) {\n-      if (item.item) {\n-        lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}\\n`);\n-        traverse(item.item, [...groupNames, item.name]);\n-      } else if (item.request?.url?.path) {\n-        const name = item.name;\n-        const method = item.request.method;\n-        const url = item.request.url.raw?.replace(\"{{baseUrl}}/\", \"\") ?? item.request.url.path.join(\"/\");\n-        const title = name;\n-        const hasToken = item.request.header?.some((h: any) => h.key.toLowerCase() === \"authorization\");\n-        const bodyRaw = item.request.body?.raw;\n-\n-        let params = \"\";\n-        let bodyArg = \"\";\n-        let typeName = \"\";\n-\n-        try {\n-          const parsed = parseRawJsonWithComments(bodyRaw || \"\");\n-          const keys = Object.keys(parsed);\n-\n-          if (keys.length === 0) {\n-            params = \"\";\n-            bodyArg = \"\";\n-          } else if (keys.length === 1) {\n-            const [k] = keys;\n-            const { value, optional } = parsed[k];\n-            const inferred = inferType(value);\n-            params = `${k}${optional ? \"?\" : \"\"}: ${inferred}${optional ? \" | null\" : \"\"}`;\n-            bodyArg = `{ ${k}: ${k} }`;\n-          } else {\n-            typeName = generateTypeName(url.split(\"/\"), name);\n-            params = `params: ${typeName}`;\n-            bodyArg = \"params\";\n-            typeNames.add(typeName);\n-          }\n-        } catch {\n-          params = \"\";\n-          bodyArg = \"\";\n-        }\n-\n-        const fnName = `${fnPrefix}${toCamel(url.split(\"/\").join(\"_\"))}`;\n-\n-        lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n-        lines.push(`\n-export async function ${fnName}(${params}) {\n-  return call${groupType}Api({\n-    title: \"${title}\",\n-    url: buildProxyUrl(\"${url}\"),\n-    ${hasToken ? \"withToken: true,\" : \"\"}\n-    ${bodyArg ? `body: ${bodyArg},` : \"\"}\n-    isCallPageLoader: true,\n-  });\n-}\n-        `.trim());\n-      }\n-    }\n-  }\n-\n-  traverse(topLevel.item);\n-\n-  const importLines = [\n-    `import { call${groupType}Api } from \"./call${groupType}Api\";`,\n-    `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n-  ];\n-\n-  if (typeNames.size > 0) {\n-    importLines.push(`import { ${Array.from(typeNames).join(\", \")} } from \"./${fnPrefix}Api.types\";`);\n-  }\n-\n-  return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n-}\n"
                },
                {
                    "date": 1750815139440,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,9 +45,8 @@\n   }\n \n   return result;\n }\n-\n export function generateApiFunctions(apiSpec: any): string {\n   const lines: string[] = [];\n   const typeNames = new Set<string>();\n \n@@ -64,11 +63,11 @@\n     const match = name.match(/\\((.*?)\\)/);\n     return match ? match[1] : \"User\";\n   }\n \n-  const groupType = extractGroupType(topLevel.name);\n-  const fnPrefix = groupType.toLowerCase();\n-  const apiCaller = `call${groupType}Api`;\n+  const groupType = extractGroupType(topLevel.name); // 🚀 중요\n+  const fnPrefix = groupType.toLowerCase();          // e.g., \"dealer\"\n+  const apiCaller = `call${groupType}Api`;           // e.g., \"callDealerApi\"\n \n   function traverse(items: any[], groupNames: string[] = []) {\n     for (const item of items) {\n       if (item.item) {\n@@ -107,9 +106,9 @@\n           params = \"\";\n           bodyArg = \"\";\n         }\n \n-        const fnName = toCamel(`${fnPrefix}-${url.split(\"/\").join(\"-\")}`);\n+        const fnName = `${fnPrefix}${toCamel(url.split(\"/\").join(\"_\"))}`;\n \n         lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n         lines.push(`\n export async function ${fnName}(${params}) {\n"
                },
                {
                    "date": 1750815250432,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,38 +45,23 @@\n   }\n \n   return result;\n }\n+\n export function generateApiFunctions(apiSpec: any): string {\n   const lines: string[] = [];\n   const typeNames = new Set<string>();\n \n-  const topLevel = Array.isArray(apiSpec)\n-    ? { name: \"UnnamedGroup\", item: apiSpec }\n-    : apiSpec;\n-\n-  if (!Array.isArray(topLevel.item)) {\n-    throw new Error(\"Invalid API spec: 'item' array missing.\");\n-  }\n-\n-  function extractGroupType(name: string): string {\n-    if (!name) return \"User\";\n-    const match = name.match(/\\((.*?)\\)/);\n-    return match ? match[1] : \"User\";\n-  }\n-\n-  const groupType = extractGroupType(topLevel.name); // 🚀 중요\n-  const fnPrefix = groupType.toLowerCase();          // e.g., \"dealer\"\n-  const apiCaller = `call${groupType}Api`;           // e.g., \"callDealerApi\"\n-\n   function traverse(items: any[], groupNames: string[] = []) {\n     for (const item of items) {\n       if (item.item) {\n         lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}\\n`);\n         traverse(item.item, [...groupNames, item.name]);\n       } else if (item.request?.url?.path) {\n         const name = item.name;\n+        const method = item.request.method;\n         const url = item.request.url.raw?.replace(\"{{baseUrl}}/\", \"\") ?? item.request.url.path.join(\"/\");\n+        const title = name;\n         const hasToken = item.request.header?.some((h: any) => h.key.toLowerCase() === \"authorization\");\n         const bodyRaw = item.request.body?.raw;\n \n         let params = \"\";\n@@ -106,15 +91,15 @@\n           params = \"\";\n           bodyArg = \"\";\n         }\n \n-        const fnName = `${fnPrefix}${toCamel(url.split(\"/\").join(\"_\"))}`;\n+        const fnName = toCamel(url.split(\"/\").join(\"_\"));\n \n         lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n         lines.push(`\n export async function ${fnName}(${params}) {\n-  return ${apiCaller}({\n-    title: \"${name}\",\n+  return callUserApi({\n+    title: \"${title}\",\n     url: buildProxyUrl(\"${url}\"),\n     ${hasToken ? \"withToken: true,\" : \"\"}\n     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n     isCallPageLoader: true,\n@@ -124,18 +109,18 @@\n       }\n     }\n   }\n \n-  traverse(topLevel.item);\n+  traverse(apiSpec, []);\n \n   const importLines = [\n-    `import { ${apiCaller} } from \"./${apiCaller}\";`,\n+    `import { callUserApi } from \"./callUserApi\";`,\n     `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n   ];\n \n   if (typeNames.size > 0) {\n     importLines.push(\n-      `import { ${Array.from(typeNames).join(\", \")} } from \"./${fnPrefix}Api.types\";`\n+      `import { ${Array.from(typeNames).join(\", \")} } from \"./userApi.types\";`\n     );\n   }\n \n   return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n"
                },
                {
                    "date": 1750815503870,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,13 +45,18 @@\n   }\n \n   return result;\n }\n-\n export function generateApiFunctions(apiSpec: any): string {\n   const lines: string[] = [];\n   const typeNames = new Set<string>();\n \n+  // 1. Extract type from name\n+  const typeMatch = apiSpec.name?.match(/\\(([^)]+)\\)/);\n+  const apiType = typeMatch?.[1] ?? \"User\"; // fallback to User\n+  const apiFuncName = `call${apiType}Api`;\n+  const apiImportPath = `./call${apiType}Api`;\n+\n   function traverse(items: any[], groupNames: string[] = []) {\n     for (const item of items) {\n       if (item.item) {\n         lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}\\n`);\n@@ -96,9 +101,9 @@\n \n         lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n         lines.push(`\n export async function ${fnName}(${params}) {\n-  return callUserApi({\n+  return ${apiFuncName}({\n     title: \"${title}\",\n     url: buildProxyUrl(\"${url}\"),\n     ${hasToken ? \"withToken: true,\" : \"\"}\n     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n@@ -109,12 +114,12 @@\n       }\n     }\n   }\n \n-  traverse(apiSpec, []);\n+  traverse(apiSpec.item || [], []);\n \n   const importLines = [\n-    `import { callUserApi } from \"./callUserApi\";`,\n+    `import { ${apiFuncName} } from \"${apiImportPath}\";`,\n     `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n   ];\n \n   if (typeNames.size > 0) {\n"
                },
                {
                    "date": 1750815527925,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,18 +45,13 @@\n   }\n \n   return result;\n }\n+\n export function generateApiFunctions(apiSpec: any): string {\n   const lines: string[] = [];\n   const typeNames = new Set<string>();\n \n-  // 1. Extract type from name\n-  const typeMatch = apiSpec.name?.match(/\\(([^)]+)\\)/);\n-  const apiType = typeMatch?.[1] ?? \"User\"; // fallback to User\n-  const apiFuncName = `call${apiType}Api`;\n-  const apiImportPath = `./call${apiType}Api`;\n-\n   function traverse(items: any[], groupNames: string[] = []) {\n     for (const item of items) {\n       if (item.item) {\n         lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}\\n`);\n@@ -101,9 +96,9 @@\n \n         lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n         lines.push(`\n export async function ${fnName}(${params}) {\n-  return ${apiFuncName}({\n+  return callUserApi({\n     title: \"${title}\",\n     url: buildProxyUrl(\"${url}\"),\n     ${hasToken ? \"withToken: true,\" : \"\"}\n     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n@@ -114,12 +109,12 @@\n       }\n     }\n   }\n \n-  traverse(apiSpec.item || [], []);\n+  traverse(apiSpec, []);\n \n   const importLines = [\n-    `import { ${apiFuncName} } from \"${apiImportPath}\";`,\n+    `import { callUserApi } from \"./callUserApi\";`,\n     `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n   ];\n \n   if (typeNames.size > 0) {\n"
                },
                {
                    "date": 1750815578053,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,13 +45,17 @@\n   }\n \n   return result;\n }\n-\n export function generateApiFunctions(apiSpec: any): string {\n   const lines: string[] = [];\n   const typeNames = new Set<string>();\n \n+  // 추출: \"👤 유저 (User)\" → \"User\"\n+  const apiClassName = (apiSpec.name?.match(/\\(([^)]+)\\)/)?.[1] ?? \"User\").trim();\n+  const apiFnName = `call${apiClassName}Api`;\n+  const apiImportPath = `./call${apiClassName}Api`;\n+\n   function traverse(items: any[], groupNames: string[] = []) {\n     for (const item of items) {\n       if (item.item) {\n         lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}\\n`);\n@@ -79,9 +83,9 @@\n             const [k] = keys;\n             const { value, optional } = parsed[k];\n             const inferred = inferType(value);\n             params = `${k}${optional ? \"?\" : \"\"}: ${inferred}${optional ? \" | null\" : \"\"}`;\n-            bodyArg = `{ ${k}: ${k} }`;\n+            bodyArg = `{ ${k} }`;\n           } else {\n             typeName = generateTypeName(url.split(\"/\"), name);\n             params = `params: ${typeName}`;\n             bodyArg = \"params\";\n@@ -96,25 +100,24 @@\n \n         lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n         lines.push(`\n export async function ${fnName}(${params}) {\n-  return callUserApi({\n+  return ${apiFnName}({\n     title: \"${title}\",\n     url: buildProxyUrl(\"${url}\"),\n     ${hasToken ? \"withToken: true,\" : \"\"}\n     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n     isCallPageLoader: true,\n   });\n-}\n-        `.trim());\n+`.trim() + \"\\n}\");\n       }\n     }\n   }\n \n-  traverse(apiSpec, []);\n+  traverse(apiSpec.item ?? [], []);\n \n   const importLines = [\n-    `import { callUserApi } from \"./callUserApi\";`,\n+    `import { ${apiFnName} } from \"${apiImportPath}\";`,\n     `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n   ];\n \n   if (typeNames.size > 0) {\n"
                },
                {
                    "date": 1750815649992,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -57,13 +57,12 @@\n \n   function traverse(items: any[], groupNames: string[] = []) {\n     for (const item of items) {\n       if (item.item) {\n-        lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}\\n`);\n+        lines.push(`// ${[...groupNames, item.name].join(\" / \")}`);\n         traverse(item.item, [...groupNames, item.name]);\n       } else if (item.request?.url?.path) {\n         const name = item.name;\n-        const method = item.request.method;\n         const url = item.request.url.raw?.replace(\"{{baseUrl}}/\", \"\") ?? item.request.url.path.join(\"/\");\n         const title = name;\n         const hasToken = item.request.header?.some((h: any) => h.key.toLowerCase() === \"authorization\");\n         const bodyRaw = item.request.body?.raw;\n@@ -97,9 +96,8 @@\n         }\n \n         const fnName = toCamel(url.split(\"/\").join(\"_\"));\n \n-        lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n         lines.push(`\n export async function ${fnName}(${params}) {\n   return ${apiFnName}({\n     title: \"${title}\",\n@@ -107,9 +105,9 @@\n     ${hasToken ? \"withToken: true,\" : \"\"}\n     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n     isCallPageLoader: true,\n   });\n-`.trim() + \"\\n}\");\n+}`);\n       }\n     }\n   }\n \n"
                },
                {
                    "date": 1750815662725,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,127 @@\n+function inferType(value: any): string {\n+  const type = typeof value;\n+  if (type === \"string\") return \"string\";\n+  if (type === \"number\") return \"number\";\n+  if (type === \"boolean\") return \"boolean\";\n+  if (Array.isArray(value)) return `${inferType(value[0])}[]`;\n+  return \"any\";\n+}\n+\n+function generateTypeName(pathParts: string[], name: string): string {\n+  const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);\n+  const clean = (s: string) =>\n+    s.replace(/[^a-zA-Z0-9]/g, \" \")\n+      .split(/\\s+/)\n+      .map(capitalize)\n+      .join(\"\");\n+  const base = pathParts.join(\"-\") || name;\n+  return clean(base) + \"Params\";\n+}\n+\n+function toCamel(str: string): string {\n+  return str\n+    .replace(/[-_\\/\\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : \"\"))\n+    .replace(/^(.)/, (c) => c.toLowerCase());\n+}\n+\n+function parseRawJsonWithComments(raw: string): Record<string, { value: any; optional: boolean }> {\n+  const result: Record<string, { value: any; optional: boolean }> = {};\n+  const lines = raw.split(\"\\n\");\n+\n+  for (const line of lines) {\n+    const match = line.match(/\"(.+?)\"\\s*:\\s*(.+?)(\\s*\\/\\/\\s*(.*))?$/);\n+    if (!match) continue;\n+\n+    const [, key, rawValue, , comment] = match;\n+    let value: any;\n+    try {\n+      value = JSON.parse(rawValue.endsWith(\",\") ? rawValue.slice(0, -1) : rawValue);\n+    } catch {\n+      value = rawValue.trim().replace(/,$/, \"\");\n+    }\n+\n+    const optional = comment?.trim() === \"?\";\n+    result[key] = { value, optional };\n+  }\n+\n+  return result;\n+}\n+\n+export function generateApiFunctions(apiSpec: any): string {\n+  const lines: string[] = [];\n+  const typeNames = new Set<string>();\n+\n+  function traverse(items: any[], groupNames: string[] = []) {\n+    for (const item of items) {\n+      if (item.item) {\n+        lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}\\n`);\n+        traverse(item.item, [...groupNames, item.name]);\n+      } else if (item.request?.url?.path) {\n+        const name = item.name;\n+        const method = item.request.method;\n+        const url = item.request.url.raw?.replace(\"{{baseUrl}}/\", \"\") ?? item.request.url.path.join(\"/\");\n+        const title = name;\n+        const hasToken = item.request.header?.some((h: any) => h.key.toLowerCase() === \"authorization\");\n+        const bodyRaw = item.request.body?.raw;\n+\n+        let params = \"\";\n+        let bodyArg = \"\";\n+        let typeName = \"\";\n+\n+        try {\n+          const parsed = parseRawJsonWithComments(bodyRaw || \"\");\n+          const keys = Object.keys(parsed);\n+\n+          if (keys.length === 0) {\n+            params = \"\";\n+            bodyArg = \"\";\n+          } else if (keys.length === 1) {\n+            const [k] = keys;\n+            const { value, optional } = parsed[k];\n+            const inferred = inferType(value);\n+            params = `${k}${optional ? \"?\" : \"\"}: ${inferred}${optional ? \" | null\" : \"\"}`;\n+            bodyArg = `{ ${k}: ${k} }`;\n+          } else {\n+            typeName = generateTypeName(url.split(\"/\"), name);\n+            params = `params: ${typeName}`;\n+            bodyArg = \"params\";\n+            typeNames.add(typeName);\n+          }\n+        } catch {\n+          params = \"\";\n+          bodyArg = \"\";\n+        }\n+\n+        const fnName = toCamel(url.split(\"/\").join(\"_\"));\n+\n+        lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n+        lines.push(`\n+export async function ${fnName}(${params}) {\n+  return callUserApi({\n+    title: \"${title}\",\n+    url: buildProxyUrl(\"${url}\"),\n+    ${hasToken ? \"withToken: true,\" : \"\"}\n+    ${bodyArg ? `body: ${bodyArg},` : \"\"}\n+    isCallPageLoader: true,\n+  });\n+}\n+        `.trim());\n+      }\n+    }\n+  }\n+\n+  traverse(apiSpec, []);\n+\n+  const importLines = [\n+    `import { callUserApi } from \"./callUserApi\";`,\n+    `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n+  ];\n+\n+  if (typeNames.size > 0) {\n+    importLines.push(\n+      `import { ${Array.from(typeNames).join(\", \")} } from \"./userApi.types\";`\n+    );\n+  }\n+\n+  return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n+}\n"
                },
                {
                    "date": 1750815796244,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -45,13 +45,18 @@\n   }\n \n   return result;\n }\n-\n export function generateApiFunctions(apiSpec: any): string {\n   const lines: string[] = [];\n   const typeNames = new Set<string>();\n \n+  // 1. 최상위 name에서 타입 추출 (괄호 안)\n+  const rootName: string = apiSpec.name || \"\";\n+  const apiTypeMatch = rootName.match(/\\(([^)]+)\\)/);\n+  const apiType = apiTypeMatch ? apiTypeMatch[1].trim() : \"User\";\n+  const apiTypeLower = apiType.charAt(0).toLowerCase() + apiType.slice(1);\n+\n   function traverse(items: any[], groupNames: string[] = []) {\n     for (const item of items) {\n       if (item.item) {\n         lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}\\n`);\n@@ -96,9 +101,9 @@\n \n         lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n         lines.push(`\n export async function ${fnName}(${params}) {\n-  return callUserApi({\n+  return call${apiType}Api({\n     title: \"${title}\",\n     url: buildProxyUrl(\"${url}\"),\n     ${hasToken ? \"withToken: true,\" : \"\"}\n     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n@@ -109,147 +114,19 @@\n       }\n     }\n   }\n \n-  traverse(apiSpec, []);\n+  traverse(apiSpec.item, []);\n \n   const importLines = [\n-    `import { callUserApi } from \"./callUserApi\";`,\n+    `import { call${apiType}Api } from \"./call${apiType}Api\";`,\n     `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n   ];\n \n   if (typeNames.size > 0) {\n     importLines.push(\n-      `import { ${Array.from(typeNames).join(\", \")} } from \"./userApi.types\";`\n+      `import { ${Array.from(typeNames).join(\", \")} } from \"./${apiTypeLower}Api.types\";`\n     );\n   }\n \n   return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n-}\n-function inferType(value: any): string {\n-  const type = typeof value;\n-  if (type === \"string\") return \"string\";\n-  if (type === \"number\") return \"number\";\n-  if (type === \"boolean\") return \"boolean\";\n-  if (Array.isArray(value)) return `${inferType(value[0])}[]`;\n-  return \"any\";\n-}\n-\n-function generateTypeName(pathParts: string[], name: string): string {\n-  const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);\n-  const clean = (s: string) =>\n-    s.replace(/[^a-zA-Z0-9]/g, \" \")\n-      .split(/\\s+/)\n-      .map(capitalize)\n-      .join(\"\");\n-  const base = pathParts.join(\"-\") || name;\n-  return clean(base) + \"Params\";\n-}\n-\n-function toCamel(str: string): string {\n-  return str\n-    .replace(/[-_\\/\\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : \"\"))\n-    .replace(/^(.)/, (c) => c.toLowerCase());\n-}\n-\n-function parseRawJsonWithComments(raw: string): Record<string, { value: any; optional: boolean }> {\n-  const result: Record<string, { value: any; optional: boolean }> = {};\n-  const lines = raw.split(\"\\n\");\n-\n-  for (const line of lines) {\n-    const match = line.match(/\"(.+?)\"\\s*:\\s*(.+?)(\\s*\\/\\/\\s*(.*))?$/);\n-    if (!match) continue;\n-\n-    const [, key, rawValue, , comment] = match;\n-    let value: any;\n-    try {\n-      value = JSON.parse(rawValue.endsWith(\",\") ? rawValue.slice(0, -1) : rawValue);\n-    } catch {\n-      value = rawValue.trim().replace(/,$/, \"\");\n-    }\n-\n-    const optional = comment?.trim() === \"?\";\n-    result[key] = { value, optional };\n-  }\n-\n-  return result;\n-}\n-export function generateApiFunctions(apiSpec: any): string {\n-  const lines: string[] = [];\n-  const typeNames = new Set<string>();\n-\n-  // 추출: \"👤 유저 (User)\" → \"User\"\n-  const apiClassName = (apiSpec.name?.match(/\\(([^)]+)\\)/)?.[1] ?? \"User\").trim();\n-  const apiFnName = `call${apiClassName}Api`;\n-  const apiImportPath = `./call${apiClassName}Api`;\n-\n-  function traverse(items: any[], groupNames: string[] = []) {\n-    for (const item of items) {\n-      if (item.item) {\n-        lines.push(`// ${[...groupNames, item.name].join(\" / \")}`);\n-        traverse(item.item, [...groupNames, item.name]);\n-      } else if (item.request?.url?.path) {\n-        const name = item.name;\n-        const url = item.request.url.raw?.replace(\"{{baseUrl}}/\", \"\") ?? item.request.url.path.join(\"/\");\n-        const title = name;\n-        const hasToken = item.request.header?.some((h: any) => h.key.toLowerCase() === \"authorization\");\n-        const bodyRaw = item.request.body?.raw;\n-\n-        let params = \"\";\n-        let bodyArg = \"\";\n-        let typeName = \"\";\n-\n-        try {\n-          const parsed = parseRawJsonWithComments(bodyRaw || \"\");\n-          const keys = Object.keys(parsed);\n-\n-          if (keys.length === 0) {\n-            params = \"\";\n-            bodyArg = \"\";\n-          } else if (keys.length === 1) {\n-            const [k] = keys;\n-            const { value, optional } = parsed[k];\n-            const inferred = inferType(value);\n-            params = `${k}${optional ? \"?\" : \"\"}: ${inferred}${optional ? \" | null\" : \"\"}`;\n-            bodyArg = `{ ${k} }`;\n-          } else {\n-            typeName = generateTypeName(url.split(\"/\"), name);\n-            params = `params: ${typeName}`;\n-            bodyArg = \"params\";\n-            typeNames.add(typeName);\n-          }\n-        } catch {\n-          params = \"\";\n-          bodyArg = \"\";\n-        }\n-\n-        const fnName = toCamel(url.split(\"/\").join(\"_\"));\n-\n-        lines.push(`\n-export async function ${fnName}(${params}) {\n-  return ${apiFnName}({\n-    title: \"${title}\",\n-    url: buildProxyUrl(\"${url}\"),\n-    ${hasToken ? \"withToken: true,\" : \"\"}\n-    ${bodyArg ? `body: ${bodyArg},` : \"\"}\n-    isCallPageLoader: true,\n-  });\n-}`);\n-      }\n-    }\n-  }\n-\n-  traverse(apiSpec.item ?? [], []);\n-\n-  const importLines = [\n-    `import { ${apiFnName} } from \"${apiImportPath}\";`,\n-    `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n-  ];\n-\n-  if (typeNames.size > 0) {\n-    importLines.push(\n-      `import { ${Array.from(typeNames).join(\", \")} } from \"./userApi.types\";`\n-    );\n-  }\n-\n-  return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n-}\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1750815839292,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,8 +56,9 @@\n   const apiType = apiTypeMatch ? apiTypeMatch[1].trim() : \"User\";\n   const apiTypeLower = apiType.charAt(0).toLowerCase() + apiType.slice(1);\n \n   function traverse(items: any[], groupNames: string[] = []) {\n+      if (!Array.isArray(items)) return; \n     for (const item of items) {\n       if (item.item) {\n         lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}\\n`);\n         traverse(item.item, [...groupNames, item.name]);\n"
                },
                {
                    "date": 1750815918677,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,11 +51,13 @@\n   const typeNames = new Set<string>();\n \n   // 1. 최상위 name에서 타입 추출 (괄호 안)\n   const rootName: string = apiSpec.name || \"\";\n+  console.log(\"rootName:\", rootName); // 디버깅\n   const apiTypeMatch = rootName.match(/\\(([^)]+)\\)/);\n   const apiType = apiTypeMatch ? apiTypeMatch[1].trim() : \"User\";\n   const apiTypeLower = apiType.charAt(0).toLowerCase() + apiType.slice(1);\n+  console.log(\"apiType:\", apiType); // 디버깅\n \n   function traverse(items: any[], groupNames: string[] = []) {\n       if (!Array.isArray(items)) return; \n     for (const item of items) {\n"
                },
                {
                    "date": 1750816202543,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,72 +23,39 @@\n     .replace(/[-_\\/\\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : \"\"))\n     .replace(/^(.)/, (c) => c.toLowerCase());\n }\n \n-function parseRawJsonWithComments(raw: string): Record<string, { value: any; optional: boolean }> {\n-  const result: Record<string, { value: any; optional: boolean }> = {};\n-  const lines = raw.split(\"\\n\");\n \n-  for (const line of lines) {\n-    const match = line.match(/\"(.+?)\"\\s*:\\s*(.+?)(\\s*\\/\\/\\s*(.*))?$/);\n-    if (!match) continue;\n-\n-    const [, key, rawValue, , comment] = match;\n-    let value: any;\n-    try {\n-      value = JSON.parse(rawValue.endsWith(\",\") ? rawValue.slice(0, -1) : rawValue);\n-    } catch {\n-      value = rawValue.trim().replace(/,$/, \"\");\n-    }\n-\n-    const optional = comment?.trim() === \"?\";\n-    result[key] = { value, optional };\n-  }\n-\n-  return result;\n-}\n export function generateApiFunctions(apiSpec: any): string {\n   const lines: string[] = [];\n   const typeNames = new Set<string>();\n \n-  // 1. 최상위 name에서 타입 추출 (괄호 안)\n-  const rootName: string = apiSpec.name || \"\";\n-  console.log(\"rootName:\", rootName); // 디버깅\n-  const apiTypeMatch = rootName.match(/\\(([^)]+)\\)/);\n-  const apiType = apiTypeMatch ? apiTypeMatch[1].trim() : \"User\";\n-  const apiTypeLower = apiType.charAt(0).toLowerCase() + apiType.slice(1);\n-  console.log(\"apiType:\", apiType); // 디버깅\n-\n-  function traverse(items: any[], groupNames: string[] = []) {\n-      if (!Array.isArray(items)) return; \n+  function traverse(items: any[]) {\n     for (const item of items) {\n       if (item.item) {\n-        lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}\\n`);\n-        traverse(item.item, [...groupNames, item.name]);\n+        traverse(item.item);\n       } else if (item.request?.url?.path) {\n         const name = item.name;\n         const method = item.request.method;\n         const url = item.request.url.raw?.replace(\"{{baseUrl}}/\", \"\") ?? item.request.url.path.join(\"/\");\n         const title = name;\n         const hasToken = item.request.header?.some((h: any) => h.key.toLowerCase() === \"authorization\");\n         const bodyRaw = item.request.body?.raw;\n \n-        let params = \"\";\n-        let bodyArg = \"\";\n-        let typeName = \"\";\n+        let params: string;\n+        let bodyArg: string;\n+        let typeName: string;\n \n         try {\n-          const parsed = parseRawJsonWithComments(bodyRaw || \"\");\n-          const keys = Object.keys(parsed);\n+          const parsedBody = JSON.parse(bodyRaw || \"{}\");\n+          const keys = Object.keys(parsedBody);\n \n           if (keys.length === 0) {\n             params = \"\";\n             bodyArg = \"\";\n           } else if (keys.length === 1) {\n-            const [k] = keys;\n-            const { value, optional } = parsed[k];\n-            const inferred = inferType(value);\n-            params = `${k}${optional ? \"?\" : \"\"}: ${inferred}${optional ? \" | null\" : \"\"}`;\n+            const k = keys[0];\n+            params = `${k}: ${inferType(parsedBody[k])}`;\n             bodyArg = `{ ${k}: ${k} }`;\n           } else {\n             typeName = generateTypeName(url.split(\"/\"), name);\n             params = `params: ${typeName}`;\n@@ -101,12 +68,11 @@\n         }\n \n         const fnName = toCamel(url.split(\"/\").join(\"_\"));\n \n-        lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n         lines.push(`\n export async function ${fnName}(${params}) {\n-  return call${apiType}Api({\n+  return callUserApi({\n     title: \"${title}\",\n     url: buildProxyUrl(\"${url}\"),\n     ${hasToken ? \"withToken: true,\" : \"\"}\n     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n@@ -117,18 +83,20 @@\n       }\n     }\n   }\n \n-  traverse(apiSpec.item, []);\n+  traverse(apiSpec);\n \n+  // 기본 import 구문\n   const importLines = [\n-    `import { call${apiType}Api } from \"./call${apiType}Api\";`,\n+    `import { callUserApi } from \"./callUserApi\";`,\n     `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n   ];\n \n+  // 타입 import 구문\n   if (typeNames.size > 0) {\n     importLines.push(\n-      `import { ${Array.from(typeNames).join(\", \")} } from \"./${apiTypeLower}Api.types\";`\n+      `import { ${Array.from(typeNames).join(\", \")} } from \"./userApi.types\";`\n     );\n   }\n \n   return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n"
                },
                {
                    "date": 1750816281052,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,11 +68,22 @@\n         }\n \n         const fnName = toCamel(url.split(\"/\").join(\"_\"));\n \n+//         lines.push(`\n+// export async function ${fnName}(${params}) {\n+//   return callUserApi({\n+//     title: \"${title}\",\n+//     url: buildProxyUrl(\"${url}\"),\n+//     ${hasToken ? \"withToken: true,\" : \"\"}\n+//     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n+//     isCallPageLoader: true,\n+//   });\n+// }\n+\n         lines.push(`\n export async function ${fnName}(${params}) {\n-  return callUserApi({\n+  return callDealerApi({\n     title: \"${title}\",\n     url: buildProxyUrl(\"${url}\"),\n     ${hasToken ? \"withToken: true,\" : \"\"}\n     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n@@ -87,17 +98,24 @@\n   traverse(apiSpec);\n \n   // 기본 import 구문\n   const importLines = [\n-    `import { callUserApi } from \"./callUserApi\";`,\n+    `import { callDealerApi } from \"./callDealerApi\";`,\n     `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n   ];\n+  // const importLines = [\n+  //   `import { callUserApi } from \"./callUserApi\";`,\n+  //   `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n+  // ];\n \n   // 타입 import 구문\n   if (typeNames.size > 0) {\n     importLines.push(\n-      `import { ${Array.from(typeNames).join(\", \")} } from \"./userApi.types\";`\n+      `import { ${Array.from(typeNames).join(\", \")} } from \"./dealerApi.types\";`\n     );\n+    // importLines.push(\n+    //   `import { ${Array.from(typeNames).join(\", \")} } from \"./userApi.types\";`\n+    // );\n   }\n \n   return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1750816606045,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -23,39 +23,64 @@\n     .replace(/[-_\\/\\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : \"\"))\n     .replace(/^(.)/, (c) => c.toLowerCase());\n }\n \n+function parseRawJsonWithComments(raw: string): Record<string, { value: any; optional: boolean }> {\n+  const result: Record<string, { value: any; optional: boolean }> = {};\n+  const lines = raw.split(\"\\n\");\n \n+  for (const line of lines) {\n+    const match = line.match(/\"(.+?)\"\\s*:\\s*(.+?)(\\s*\\/\\/\\s*(.*))?$/);\n+    if (!match) continue;\n+\n+    const [, key, rawValue, , comment] = match;\n+    let value: any;\n+    try {\n+      value = JSON.parse(rawValue.endsWith(\",\") ? rawValue.slice(0, -1) : rawValue);\n+    } catch {\n+      value = rawValue.trim().replace(/,$/, \"\");\n+    }\n+\n+    const optional = comment?.trim() === \"?\";\n+    result[key] = { value, optional };\n+  }\n+\n+  return result;\n+}\n+\n export function generateApiFunctions(apiSpec: any): string {\n   const lines: string[] = [];\n   const typeNames = new Set<string>();\n \n-  function traverse(items: any[]) {\n+  function traverse(items: any[], groupNames: string[] = []) {\n     for (const item of items) {\n       if (item.item) {\n-        traverse(item.item);\n+        lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}\\n`);\n+        traverse(item.item, [...groupNames, item.name]);\n       } else if (item.request?.url?.path) {\n         const name = item.name;\n         const method = item.request.method;\n         const url = item.request.url.raw?.replace(\"{{baseUrl}}/\", \"\") ?? item.request.url.path.join(\"/\");\n         const title = name;\n         const hasToken = item.request.header?.some((h: any) => h.key.toLowerCase() === \"authorization\");\n         const bodyRaw = item.request.body?.raw;\n \n-        let params: string;\n-        let bodyArg: string;\n-        let typeName: string;\n+        let params = \"\";\n+        let bodyArg = \"\";\n+        let typeName = \"\";\n \n         try {\n-          const parsedBody = JSON.parse(bodyRaw || \"{}\");\n-          const keys = Object.keys(parsedBody);\n+          const parsed = parseRawJsonWithComments(bodyRaw || \"\");\n+          const keys = Object.keys(parsed);\n \n           if (keys.length === 0) {\n             params = \"\";\n             bodyArg = \"\";\n           } else if (keys.length === 1) {\n-            const k = keys[0];\n-            params = `${k}: ${inferType(parsedBody[k])}`;\n+            const [k] = keys;\n+            const { value, optional } = parsed[k];\n+            const inferred = inferType(value);\n+            params = `${k}${optional ? \"?\" : \"\"}: ${inferred}${optional ? \" | null\" : \"\"}`;\n             bodyArg = `{ ${k}: ${k} }`;\n           } else {\n             typeName = generateTypeName(url.split(\"/\"), name);\n             params = `params: ${typeName}`;\n@@ -68,22 +93,12 @@\n         }\n \n         const fnName = toCamel(url.split(\"/\").join(\"_\"));\n \n-//         lines.push(`\n-// export async function ${fnName}(${params}) {\n-//   return callUserApi({\n-//     title: \"${title}\",\n-//     url: buildProxyUrl(\"${url}\"),\n-//     ${hasToken ? \"withToken: true,\" : \"\"}\n-//     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n-//     isCallPageLoader: true,\n-//   });\n-// }\n-\n+        lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n         lines.push(`\n export async function ${fnName}(${params}) {\n-  return callDealerApi({\n+  return callUserApi({\n     title: \"${title}\",\n     url: buildProxyUrl(\"${url}\"),\n     ${hasToken ? \"withToken: true,\" : \"\"}\n     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n@@ -94,28 +109,19 @@\n       }\n     }\n   }\n \n-  traverse(apiSpec);\n+  traverse(apiSpec, []);\n \n-  // 기본 import 구문\n   const importLines = [\n-    `import { callDealerApi } from \"./callDealerApi\";`,\n+    `import { callUserApi } from \"./callUserApi\";`,\n     `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n   ];\n-  // const importLines = [\n-  //   `import { callUserApi } from \"./callUserApi\";`,\n-  //   `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n-  // ];\n \n-  // 타입 import 구문\n   if (typeNames.size > 0) {\n     importLines.push(\n-      `import { ${Array.from(typeNames).join(\", \")} } from \"./dealerApi.types\";`\n+      `import { ${Array.from(typeNames).join(\", \")} } from \"./userApi.types\";`\n     );\n-    // importLines.push(\n-    //   `import { ${Array.from(typeNames).join(\", \")} } from \"./userApi.types\";`\n-    // );\n   }\n\\ No newline at end of file\n \n   return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n-}\n+}\n"
                },
                {
                    "date": 1750816661082,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,32 +96,53 @@\n \n         lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n         lines.push(`\n export async function ${fnName}(${params}) {\n-  return callUserApi({\n+  return callDealerApi({\n     title: \"${title}\",\n     url: buildProxyUrl(\"${url}\"),\n     ${hasToken ? \"withToken: true,\" : \"\"}\n     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n     isCallPageLoader: true,\n   });\n }\n         `.trim());\n+//         lines.push(`\n+// export async function ${fnName}(${params}) {\n+//   return callUserApi({\n+//     title: \"${title}\",\n+//     url: buildProxyUrl(\"${url}\"),\n+//     ${hasToken ? \"withToken: true,\" : \"\"}\n+//     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n+//     isCallPageLoader: true,\n+//   });\n+// }\n+//         `.trim());\n       }\n     }\n   }\n \n   traverse(apiSpec, []);\n \n   const importLines = [\n\\ No newline at end of file\n-    `import { callUserApi } from \"./callUserApi\";`,\n+    `import { callDealerApi } from \"./callDealerApi\";`,\n     `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n   ];\n \n   if (typeNames.size > 0) {\n     importLines.push(\n-      `import { ${Array.from(typeNames).join(\", \")} } from \"./userApi.types\";`\n+      `import { ${Array.from(typeNames).join(\", \")} } from \"./dealerApi.types\";`\n     );\n   }\n+  // const importLines = [\n+  //   `import { callUserApi } from \"./callUserApi\";`,\n+  //   `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n+  // ];\n \n+  // if (typeNames.size > 0) {\n+  //   importLines.push(\n+  //     `import { ${Array.from(typeNames).join(\", \")} } from \"./userApi.types\";`\n+  //   );\n+  // }\n+\n   return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n-}\n+}\n"
                },
                {
                    "date": 1750913297144,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,9 +46,14 @@\n \n   return result;\n }\n \n-export function generateApiFunctions(apiSpec: any): string {\n+export function generateApiFunctions(apiSpec: any, apiType: string): string {\n+  const capitalized = apiType.charAt(0).toUpperCase() + apiType.slice(1);\n+  const callFnName = `call${capitalized}Api`;\n+  const apiImportPath = `./call${capitalized}Api`;\n+  const typeImportPath = `./${apiType.toLowerCase()}Api.types`;\n+\n   const lines: string[] = [];\n   const typeNames = new Set<string>();\n \n   function traverse(items: any[], groupNames: string[] = []) {\n@@ -96,53 +101,31 @@\n \n         lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n         lines.push(`\n export async function ${fnName}(${params}) {\n-  return callDealerApi({\n+  return ${callFnName}({\n     title: \"${title}\",\n     url: buildProxyUrl(\"${url}\"),\n     ${hasToken ? \"withToken: true,\" : \"\"}\n     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n     isCallPageLoader: true,\n   });\n }\n         `.trim());\n-//         lines.push(`\n-// export async function ${fnName}(${params}) {\n-//   return callUserApi({\n-//     title: \"${title}\",\n-//     url: buildProxyUrl(\"${url}\"),\n-//     ${hasToken ? \"withToken: true,\" : \"\"}\n-//     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n-//     isCallPageLoader: true,\n-//   });\n-// }\n-//         `.trim());\n       }\n     }\n   }\n \n   traverse(apiSpec, []);\n \n   const importLines = [\n-    `import { callDealerApi } from \"./callDealerApi\";`,\n+    `import { ${callFnName} } from \"${apiImportPath}\";`,\n     `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n   ];\n \n   if (typeNames.size > 0) {\n-    importLines.push(\n-      `import { ${Array.from(typeNames).join(\", \")} } from \"./dealerApi.types\";`\n-    );\n+    importLines.push(`import { ${Array.from(typeNames).join(\", \")} } from \"${typeImportPath}\";`);\n   }\n-  // const importLines = [\n-  //   `import { callUserApi } from \"./callUserApi\";`,\n-  //   `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n-  // ];\n \n-  // if (typeNames.size > 0) {\n-  //   importLines.push(\n-  //     `import { ${Array.from(typeNames).join(\", \")} } from \"./userApi.types\";`\n-  //   );\n-  // }\n-\n   return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n }\n+\n"
                },
                {
                    "date": 1750923304372,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,19 @@\n function inferType(value: any): string {\n   const type = typeof value;\n-  if (type === \"string\") return \"string\";\n-  if (type === \"number\") return \"number\";\n-  if (type === \"boolean\") return \"boolean\";\n-  if (Array.isArray(value)) return `${inferType(value[0])}[]`;\n-  return \"any\";\n+  if (value === null) return \"null\";\n+  if (Array.isArray(value)) {\n+    if (value.length === 0) return \"any[]\";\n+    return `${inferType(value[0])}[]`;\n+  }\n+  if (type === \"object\") {\n+    const entries = Object.entries(value)\n+      .map(([k, v]) => `${k}: ${inferType(v)}`)\n+      .join(\"; \");\n+    return `{ ${entries} }`;\n+  }\n+  if (type === \"string\") return `\"${value}\"`; // for enums like \"ASC\"\n+  return type;\n }\n \n function generateTypeName(pathParts: string[], name: string): string {\n   const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);\n@@ -127,4 +135,5 @@\n   }\n \n   return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n }\n+\n"
                },
                {
                    "date": 1750923399126,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,21 +1,24 @@\n function inferType(value: any): string {\n-  const type = typeof value;\n   if (value === null) return \"null\";\n   if (Array.isArray(value)) {\n     if (value.length === 0) return \"any[]\";\n     return `${inferType(value[0])}[]`;\n   }\n-  if (type === \"object\") {\n+  if (typeof value === \"object\") {\n     const entries = Object.entries(value)\n       .map(([k, v]) => `${k}: ${inferType(v)}`)\n       .join(\"; \");\n     return `{ ${entries} }`;\n   }\n-  if (type === \"string\") return `\"${value}\"`; // for enums like \"ASC\"\n-  return type;\n+  if (typeof value === \"string\") {\n+    if (value === \"ASC\" || value === \"DESC\") return `\"ASC\" | \"DESC\" | null`;\n+    return \"string\";\n+  }\n+  return typeof value;\n }\n \n+\n function generateTypeName(pathParts: string[], name: string): string {\n   const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);\n   const clean = (s: string) =>\n     s.replace(/[^a-zA-Z0-9]/g, \" \")\n"
                },
                {
                    "date": 1750923424053,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,21 +1,21 @@\n function inferType(value: any): string {\n-  if (value === null) return \"null\";\n   if (Array.isArray(value)) {\n     if (value.length === 0) return \"any[]\";\n     return `${inferType(value[0])}[]`;\n   }\n+  if (value === null) return \"any\";\n   if (typeof value === \"object\") {\n-    const entries = Object.entries(value)\n+    // 객체 타입 처리\n+    const fields = Object.entries(value)\n       .map(([k, v]) => `${k}: ${inferType(v)}`)\n       .join(\"; \");\n-    return `{ ${entries} }`;\n+    return `{ ${fields} }`;\n   }\n-  if (typeof value === \"string\") {\n-    if (value === \"ASC\" || value === \"DESC\") return `\"ASC\" | \"DESC\" | null`;\n-    return \"string\";\n-  }\n-  return typeof value;\n+  if (typeof value === \"string\") return \"string\";\n+  if (typeof value === \"number\") return \"number\";\n+  if (typeof value === \"boolean\") return \"boolean\";\n+  return \"any\";\n }\n \n \n function generateTypeName(pathParts: string[], name: string): string {\n"
                },
                {
                    "date": 1750923540543,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,9 +4,9 @@\n     return `${inferType(value[0])}[]`;\n   }\n   if (value === null) return \"any\";\n   if (typeof value === \"object\") {\n-    // 객체 타입 처리\n+    if (value === undefined) return \"any\";\n     const fields = Object.entries(value)\n       .map(([k, v]) => `${k}: ${inferType(v)}`)\n       .join(\"; \");\n     return `{ ${fields} }`;\n@@ -16,9 +16,8 @@\n   if (typeof value === \"boolean\") return \"boolean\";\n   return \"any\";\n }\n \n-\n function generateTypeName(pathParts: string[], name: string): string {\n   const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);\n   const clean = (s: string) =>\n     s.replace(/[^a-zA-Z0-9]/g, \" \")\n@@ -57,16 +56,31 @@\n \n   return result;\n }\n \n+// 중첩 타입을 올바르게 생성하는 함수\n+function generateTypeFromParsed(parsed: Record<string, { value: any; optional: boolean }>): string {\n+  return (\n+    \"{\\n\" +\n+    Object.entries(parsed)\n+      .map(([k, { value, optional }]) => {\n+        const type = inferType(value);\n+        return `  ${k}${optional ? \"?\" : \"\"}: ${type};`;\n+      })\n+      .join(\"\\n\") +\n+    \"\\n}\"\n+  );\n+}\n+\n export function generateApiFunctions(apiSpec: any, apiType: string): string {\n   const capitalized = apiType.charAt(0).toUpperCase() + apiType.slice(1);\n   const callFnName = `call${capitalized}Api`;\n   const apiImportPath = `./call${capitalized}Api`;\n   const typeImportPath = `./${apiType.toLowerCase()}Api.types`;\n \n   const lines: string[] = [];\n   const typeNames = new Set<string>();\n+  const typeDefs: string[] = [];\n \n   function traverse(items: any[], groupNames: string[] = []) {\n     for (const item of items) {\n       if (item.item) {\n@@ -98,8 +112,10 @@\n             params = `${k}${optional ? \"?\" : \"\"}: ${inferred}${optional ? \" | null\" : \"\"}`;\n             bodyArg = `{ ${k}: ${k} }`;\n           } else {\n             typeName = generateTypeName(url.split(\"/\"), name);\n+            const typeDef = `export type ${typeName} = ${generateTypeFromParsed(parsed)};`;\n+            typeDefs.push(typeDef);\n             params = `params: ${typeName}`;\n             bodyArg = \"params\";\n             typeNames.add(typeName);\n           }\n@@ -136,7 +152,7 @@\n   if (typeNames.size > 0) {\n     importLines.push(`import { ${Array.from(typeNames).join(\", \")} } from \"${typeImportPath}\";`);\n   }\n \n-  return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n-}\n-\n+  // 타입 정의를 상단에 추가\n+  return [...typeDefs, ...importLines, \"\", ...lines].join(\"\\n\\n\");\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1750923601702,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -34,28 +34,29 @@\n     .replace(/^(.)/, (c) => c.toLowerCase());\n }\n \n function parseRawJsonWithComments(raw: string): Record<string, { value: any; optional: boolean }> {\n-  const result: Record<string, { value: any; optional: boolean }> = {};\n-  const lines = raw.split(\"\\n\");\n-\n-  for (const line of lines) {\n-    const match = line.match(/\"(.+?)\"\\s*:\\s*(.+?)(\\s*\\/\\/\\s*(.*))?$/);\n-    if (!match) continue;\n-\n-    const [, key, rawValue, , comment] = match;\n-    let value: any;\n-    try {\n-      value = JSON.parse(rawValue.endsWith(\",\") ? rawValue.slice(0, -1) : rawValue);\n-    } catch {\n-      value = rawValue.trim().replace(/,$/, \"\");\n+  // 주석 제거 (// 이후 모두 제거)\n+  const noComments = raw\n+    .split('\\n')\n+    .map(line => line.replace(/\\/\\/.*$/, ''))\n+    .join('\\n');\n+  let obj: any = {};\n+  try {\n+    obj = JSON.parse(noComments);\n+  } catch {\n+    return {};\n+  }\n+  function walk(obj: any): Record<string, { value: any; optional: boolean }> {\n+    const result: Record<string, { value: any; optional: boolean }> = {};\n+    for (const key in obj) {\n+      const value = obj[key];\n+      // 중첩 객체/배열도 재귀적으로 처리\n+      result[key] = { value, optional: false };\n     }\n-\n-    const optional = comment?.trim() === \"?\";\n-    result[key] = { value, optional };\n+    return result;\n   }\n-\n-  return result;\n+  return walk(obj);\n }\n \n // 중첩 타입을 올바르게 생성하는 함수\n function generateTypeFromParsed(parsed: Record<string, { value: any; optional: boolean }>): string {\n"
                },
                {
                    "date": 1750923723814,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,23 +1,35 @@\n-function inferType(value: any): string {\n+function inferType(value: any, parentKey = \"\", typeDefs: string[] = [], typeNames: Set<string> = new Set()): string {\n   if (Array.isArray(value)) {\n     if (value.length === 0) return \"any[]\";\n-    return `${inferType(value[0])}[]`;\n+    return `${inferType(value[0], parentKey, typeDefs, typeNames)}[]`;\n   }\n   if (value === null) return \"any\";\n   if (typeof value === \"object\") {\n     if (value === undefined) return \"any\";\n-    const fields = Object.entries(value)\n-      .map(([k, v]) => `${k}: ${inferType(v)}`)\n-      .join(\"; \");\n-    return `{ ${fields} }`;\n+    // 중첩 객체는 별도 타입으로 분리\n+    const typeName = parentKey ? capitalize(parentKey) + \"Type\" : \"\";\n+    if (typeName && !typeNames.has(typeName)) {\n+      const fields = Object.entries(value)\n+        .map(([k, v]) => `${k}: ${inferType(v, typeName + capitalize(k), typeDefs, typeNames)}`)\n+        .join(\"; \");\n+      typeDefs.push(`export type ${typeName} = { ${fields} };`);\n+      typeNames.add(typeName);\n+    }\n+    return typeName || \"{ \" + Object.entries(value)\n+      .map(([k, v]) => `${k}: ${inferType(v, parentKey + capitalize(k), typeDefs, typeNames)}`)\n+      .join(\"; \") + \" }\";\n   }\n   if (typeof value === \"string\") return \"string\";\n   if (typeof value === \"number\") return \"number\";\n   if (typeof value === \"boolean\") return \"boolean\";\n   return \"any\";\n }\n \n+function capitalize(str: string) {\n+  return str.charAt(0).toUpperCase() + str.slice(1);\n+}\n+\n function generateTypeName(pathParts: string[], name: string): string {\n   const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);\n   const clean = (s: string) =>\n     s.replace(/[^a-zA-Z0-9]/g, \" \")\n@@ -49,23 +61,22 @@\n   function walk(obj: any): Record<string, { value: any; optional: boolean }> {\n     const result: Record<string, { value: any; optional: boolean }> = {};\n     for (const key in obj) {\n       const value = obj[key];\n-      // 중첩 객체/배열도 재귀적으로 처리\n       result[key] = { value, optional: false };\n     }\n     return result;\n   }\n   return walk(obj);\n }\n \n-// 중첩 타입을 올바르게 생성하는 함수\n-function generateTypeFromParsed(parsed: Record<string, { value: any; optional: boolean }>): string {\n+// 중첩 타입을 올바르게 생성하는 함수 (별도 타입 분리 지원)\n+function generateTypeFromParsed(parsed: Record<string, { value: any; optional: boolean }>, parentName: string, typeDefs: string[], typeNames: Set<string>): string {\n   return (\n     \"{\\n\" +\n     Object.entries(parsed)\n       .map(([k, { value, optional }]) => {\n-        const type = inferType(value);\n+        const type = inferType(value, parentName + capitalize(k), typeDefs, typeNames);\n         return `  ${k}${optional ? \"?\" : \"\"}: ${type};`;\n       })\n       .join(\"\\n\") +\n     \"\\n}\"\n@@ -108,14 +119,15 @@\n             bodyArg = \"\";\n           } else if (keys.length === 1) {\n             const [k] = keys;\n             const { value, optional } = parsed[k];\n-            const inferred = inferType(value);\n+            const inferred = inferType(value, capitalize(name) + capitalize(k), typeDefs, typeNames);\n             params = `${k}${optional ? \"?\" : \"\"}: ${inferred}${optional ? \" | null\" : \"\"}`;\n             bodyArg = `{ ${k}: ${k} }`;\n           } else {\n             typeName = generateTypeName(url.split(\"/\"), name);\n-            const typeDef = `export type ${typeName} = ${generateTypeFromParsed(parsed)};`;\n+            const typeDef = `export type ${typeName} = ${generateTypeFromParsed(parsed, typeName, typeDefs, typeNames)};`;\n+            typeDefs.push(...typeDefs.filter(def => def.startsWith(\"export type\") && !def.includes(typeName))); // 중복 방지\n             typeDefs.push(typeDef);\n             params = `params: ${typeName}`;\n             bodyArg = \"params\";\n             typeNames.add(typeName);\n"
                },
                {
                    "date": 1750923989838,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,35 +1,13 @@\n-function inferType(value: any, parentKey = \"\", typeDefs: string[] = [], typeNames: Set<string> = new Set()): string {\n-  if (Array.isArray(value)) {\n-    if (value.length === 0) return \"any[]\";\n-    return `${inferType(value[0], parentKey, typeDefs, typeNames)}[]`;\n-  }\n-  if (value === null) return \"any\";\n-  if (typeof value === \"object\") {\n-    if (value === undefined) return \"any\";\n-    // 중첩 객체는 별도 타입으로 분리\n-    const typeName = parentKey ? capitalize(parentKey) + \"Type\" : \"\";\n-    if (typeName && !typeNames.has(typeName)) {\n-      const fields = Object.entries(value)\n-        .map(([k, v]) => `${k}: ${inferType(v, typeName + capitalize(k), typeDefs, typeNames)}`)\n-        .join(\"; \");\n-      typeDefs.push(`export type ${typeName} = { ${fields} };`);\n-      typeNames.add(typeName);\n-    }\n-    return typeName || \"{ \" + Object.entries(value)\n-      .map(([k, v]) => `${k}: ${inferType(v, parentKey + capitalize(k), typeDefs, typeNames)}`)\n-      .join(\"; \") + \" }\";\n-  }\n-  if (typeof value === \"string\") return \"string\";\n-  if (typeof value === \"number\") return \"number\";\n-  if (typeof value === \"boolean\") return \"boolean\";\n+function inferType(value: any): string {\n+  const type = typeof value;\n+  if (type === \"string\") return \"string\";\n+  if (type === \"number\") return \"number\";\n+  if (type === \"boolean\") return \"boolean\";\n+  if (Array.isArray(value)) return `${inferType(value[0])}[]`;\n   return \"any\";\n }\n \n-function capitalize(str: string) {\n-  return str.charAt(0).toUpperCase() + str.slice(1);\n-}\n-\n function generateTypeName(pathParts: string[], name: string): string {\n   const capitalize = (str: string) => str.charAt(0).toUpperCase() + str.slice(1);\n   const clean = (s: string) =>\n     s.replace(/[^a-zA-Z0-9]/g, \" \")\n@@ -46,53 +24,33 @@\n     .replace(/^(.)/, (c) => c.toLowerCase());\n }\n \n function parseRawJsonWithComments(raw: string): Record<string, { value: any; optional: boolean }> {\n-  // 주석 제거 (// 이후 모두 제거)\n-  const noComments = raw\n-    .split('\\n')\n-    .map(line => line.replace(/\\/\\/.*$/, ''))\n-    .join('\\n');\n-  let obj: any = {};\n-  try {\n-    obj = JSON.parse(noComments);\n-  } catch {\n-    return {};\n-  }\n-  function walk(obj: any): Record<string, { value: any; optional: boolean }> {\n-    const result: Record<string, { value: any; optional: boolean }> = {};\n-    for (const key in obj) {\n-      const value = obj[key];\n-      result[key] = { value, optional: false };\n+  const result: Record<string, { value: any; optional: boolean }> = {};\n+  const lines = raw.split(\"\\n\");\n+\n+  for (const line of lines) {\n+    const match = line.match(/\"(.+?)\"\\s*:\\s*(.+?)(\\s*\\/\\/\\s*(.*))?$/);\n+    if (!match) continue;\n+\n+    const [, key, rawValue, , comment] = match;\n+    let value: any;\n+    try {\n+      value = JSON.parse(rawValue.endsWith(\",\") ? rawValue.slice(0, -1) : rawValue);\n+    } catch {\n+      value = rawValue.trim().replace(/,$/, \"\");\n     }\n-    return result;\n+\n+    const optional = comment?.trim() === \"?\";\n+    result[key] = { value, optional };\n   }\n-  return walk(obj);\n-}\n \n-// 중첩 타입을 올바르게 생성하는 함수 (별도 타입 분리 지원)\n-function generateTypeFromParsed(parsed: Record<string, { value: any; optional: boolean }>, parentName: string, typeDefs: string[], typeNames: Set<string>): string {\n-  return (\n-    \"{\\n\" +\n-    Object.entries(parsed)\n-      .map(([k, { value, optional }]) => {\n-        const type = inferType(value, parentName + capitalize(k), typeDefs, typeNames);\n-        return `  ${k}${optional ? \"?\" : \"\"}: ${type};`;\n-      })\n-      .join(\"\\n\") +\n-    \"\\n}\"\n-  );\n+  return result;\n }\n \n-export function generateApiFunctions(apiSpec: any, apiType: string): string {\n-  const capitalized = apiType.charAt(0).toUpperCase() + apiType.slice(1);\n-  const callFnName = `call${capitalized}Api`;\n-  const apiImportPath = `./call${capitalized}Api`;\n-  const typeImportPath = `./${apiType.toLowerCase()}Api.types`;\n-\n+export function generateApiFunctions(apiSpec: any): string {\n   const lines: string[] = [];\n   const typeNames = new Set<string>();\n-  const typeDefs: string[] = [];\n \n   function traverse(items: any[], groupNames: string[] = []) {\n     for (const item of items) {\n       if (item.item) {\n@@ -119,16 +77,13 @@\n             bodyArg = \"\";\n           } else if (keys.length === 1) {\n             const [k] = keys;\n             const { value, optional } = parsed[k];\n-            const inferred = inferType(value, capitalize(name) + capitalize(k), typeDefs, typeNames);\n+            const inferred = inferType(value);\n             params = `${k}${optional ? \"?\" : \"\"}: ${inferred}${optional ? \" | null\" : \"\"}`;\n             bodyArg = `{ ${k}: ${k} }`;\n           } else {\n             typeName = generateTypeName(url.split(\"/\"), name);\n-            const typeDef = `export type ${typeName} = ${generateTypeFromParsed(parsed, typeName, typeDefs, typeNames)};`;\n-            typeDefs.push(...typeDefs.filter(def => def.startsWith(\"export type\") && !def.includes(typeName))); // 중복 방지\n-            typeDefs.push(typeDef);\n             params = `params: ${typeName}`;\n             bodyArg = \"params\";\n             typeNames.add(typeName);\n           }\n@@ -141,31 +96,53 @@\n \n         lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n         lines.push(`\n export async function ${fnName}(${params}) {\n-  return ${callFnName}({\n+  return callDealerApi({\n     title: \"${title}\",\n     url: buildProxyUrl(\"${url}\"),\n     ${hasToken ? \"withToken: true,\" : \"\"}\n     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n     isCallPageLoader: true,\n   });\n }\n         `.trim());\n+//         lines.push(`\n+// export async function ${fnName}(${params}) {\n+//   return callUserApi({\n+//     title: \"${title}\",\n+//     url: buildProxyUrl(\"${url}\"),\n+//     ${hasToken ? \"withToken: true,\" : \"\"}\n+//     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n+//     isCallPageLoader: true,\n+//   });\n+// }\n+//         `.trim());\n       }\n     }\n   }\n \n   traverse(apiSpec, []);\n \n\\ No newline at end of file\n   const importLines = [\n-    `import { ${callFnName} } from \"${apiImportPath}\";`,\n+    `import { callDealerApi } from \"./callDealerApi\";`,\n     `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n   ];\n \n   if (typeNames.size > 0) {\n-    importLines.push(`import { ${Array.from(typeNames).join(\", \")} } from \"${typeImportPath}\";`);\n+    importLines.push(\n+      `import { ${Array.from(typeNames).join(\", \")} } from \"./dealerApi.types\";`\n+    );\n   }\n+  // const importLines = [\n+  //   `import { callUserApi } from \"./callUserApi\";`,\n+  //   `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n+  // ];\n \n-  // 타입 정의를 상단에 추가\n-  return [...typeDefs, ...importLines, \"\", ...lines].join(\"\\n\\n\");\n-}\n+  // if (typeNames.size > 0) {\n+  //   importLines.push(\n+  //     `import { ${Array.from(typeNames).join(\", \")} } from \"./userApi.types\";`\n+  //   );\n+  // }\n+\n+  return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n+}\n"
                },
                {
                    "date": 1750999566726,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,9 +46,14 @@\n \n   return result;\n }\n \n-export function generateApiFunctions(apiSpec: any): string {\n+export function generateApiFunctions(apiSpec: any, apiType: string): string {\n+  const capitalized = apiType.charAt(0).toUpperCase() + apiType.slice(1);\n+  const callFnName = `call${capitalized}Api`;\n+  const apiImportPath = `./call${capitalized}Api`;\n+  const typeImportPath = `./${apiType.toLowerCase()}Api.types`;\n+\n   const lines: string[] = [];\n   const typeNames = new Set<string>();\n \n   function traverse(items: any[], groupNames: string[] = []) {\n@@ -96,53 +101,31 @@\n \n         lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n         lines.push(`\n export async function ${fnName}(${params}) {\n-  return callDealerApi({\n+  return ${callFnName}({\n     title: \"${title}\",\n     url: buildProxyUrl(\"${url}\"),\n     ${hasToken ? \"withToken: true,\" : \"\"}\n     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n     isCallPageLoader: true,\n   });\n }\n         `.trim());\n-//         lines.push(`\n-// export async function ${fnName}(${params}) {\n-//   return callUserApi({\n-//     title: \"${title}\",\n-//     url: buildProxyUrl(\"${url}\"),\n-//     ${hasToken ? \"withToken: true,\" : \"\"}\n-//     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n-//     isCallPageLoader: true,\n-//   });\n-// }\n-//         `.trim());\n       }\n     }\n   }\n \n   traverse(apiSpec, []);\n \n   const importLines = [\n-    `import { callDealerApi } from \"./callDealerApi\";`,\n+    `import { ${callFnName} } from \"${apiImportPath}\";`,\n     `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n   ];\n \n   if (typeNames.size > 0) {\n-    importLines.push(\n-      `import { ${Array.from(typeNames).join(\", \")} } from \"./dealerApi.types\";`\n-    );\n+    importLines.push(`import { ${Array.from(typeNames).join(\", \")} } from \"${typeImportPath}\";`);\n   }\n-  // const importLines = [\n-  //   `import { callUserApi } from \"./callUserApi\";`,\n-  //   `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n-  // ];\n \n-  // if (typeNames.size > 0) {\n-  //   importLines.push(\n-  //     `import { ${Array.from(typeNames).join(\", \")} } from \"./userApi.types\";`\n-  //   );\n-  // }\n-\n   return [...importLines, \"\", ...lines].join(\"\\n\\n\");\n }\n+\n"
                },
                {
                    "date": 1751243784660,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -46,17 +46,21 @@\n \n   return result;\n }\n \n-export function generateApiFunctions(apiSpec: any, apiType: string): string {\n+export function generateApiFunctions(apiSpec: any, apiType: string, useProxy: boolean = true): string {\n   const capitalized = apiType.charAt(0).toUpperCase() + apiType.slice(1);\n   const callFnName = `call${capitalized}Api`;\n   const apiImportPath = `./call${capitalized}Api`;\n   const typeImportPath = `./${apiType.toLowerCase()}Api.types`;\n \n   const lines: string[] = [];\n   const typeNames = new Set<string>();\n \n+  if (!useProxy) {\n+    lines.push(`const BASE_URL = process.env.NEXT_PUBLIC_API_HOST!;`);\n+  }\n+\n   function traverse(items: any[], groupNames: string[] = []) {\n     for (const item of items) {\n       if (item.item) {\n         lines.push(`\\n// ${[...groupNames, item.name].join(\" / \")}\\n`);\n@@ -98,14 +102,18 @@\n         }\n \n         const fnName = toCamel(url.split(\"/\").join(\"_\"));\n \n+        const urlLine = useProxy\n+          ? `url: buildProxyUrl(\"${url}\"),`\n+          : `url: \\`\\${BASE_URL}/${url}\\`,`; // BASE_URL + URL 조합으로 구성\n+\n         lines.push(`// ${[...groupNames, name].join(\" / \")}`);\n         lines.push(`\n export async function ${fnName}(${params}) {\n   return ${callFnName}({\n     title: \"${title}\",\n-    url: buildProxyUrl(\"${url}\"),\n+    ${urlLine}\n     ${hasToken ? \"withToken: true,\" : \"\"}\n     ${bodyArg ? `body: ${bodyArg},` : \"\"}\n     isCallPageLoader: true,\n   });\n@@ -118,11 +126,14 @@\n   traverse(apiSpec, []);\n \n   const importLines = [\n     `import { ${callFnName} } from \"${apiImportPath}\";`,\n-    `import { buildProxyUrl } from \"@/lib/config/apiHost\";`,\n   ];\n \n+  if (useProxy) {\n+    importLines.push(`import { buildProxyUrl } from \"@/lib/config/apiHost\";`);\n+  }\n+\n   if (typeNames.size > 0) {\n     importLines.push(`import { ${Array.from(typeNames).join(\", \")} } from \"${typeImportPath}\";`);\n   }\n \n"
                }
            ],
            "date": 1750729996840,
            "name": "Commit-0",
            "content": "export function generateApiFunctions(apiSpec: any): string {\n  const lines: string[] = [];\n\n  function traverse(items: any[]) {\n    for (const item of items) {\n      if (item.item) {\n        // 중간 그룹일 경우 재귀\n        traverse(item.item);\n      } else if (item.request?.url?.path) {\n        const name = item.name;\n        const method = item.request.method;\n        const url = item.request.url.raw?.replace(\"{{baseUrl}}/\", \"\") ?? item.request.url.path.join(\"/\");\n        const title = name;\n        const hasToken = item.request.header?.some((h: any) => h.key.toLowerCase() === \"authorization\");\n        const bodyRaw = item.request.body?.raw;\n\n        let params: string;\n        let bodyArg: string;\n        let typeName: string;\n\n        try {\n          const parsedBody = JSON.parse(bodyRaw || \"{}\");\n          const keys = Object.keys(parsedBody);\n\n          if (keys.length === 0) {\n            params = \"\";\n            bodyArg = \"\";\n          } else if (keys.length === 1) {\n            const k = keys[0];\n            params = `${k}: ${inferType(parsedBody[k])}`;\n            bodyArg = `{ ${k}: ${k} }`;\n          } else {\n            typeName = generateTypeName(url.split(\"/\"), name);\n            params = `params: ${typeName}`;\n            bodyArg = \"params\";\n          }\n        } catch {\n          params = \"\";\n          bodyArg = \"\";\n        }\n\n        const fnName = toCamel(url.split(\"/\").join(\"_\"));\n\n        lines.push(`\nexport async function ${fnName}(${params}) {\n  return callUserApi({\n    title: \"${title}\",\n    url: buildProxyUrl(\"${url}\"),\n    ${hasToken ? \"withToken: true,\" : \"\"}\n    ${bodyArg ? `body: ${bodyArg},` : \"\"}\n    isCallPageLoader: true,\n  });\n}\n        `.trim());\n      }\n    }\n  }\n\n  traverse(apiSpec);\n\n  return lines.join(\"\\n\\n\");\n}\n\nfunction inferType(val: any): string {\n  const type = typeof val;\n  if (type === \"string\") return \"string\";\n  if (type === \"number\") return \"number\";\n  if (type === \"boolean\") return \"boolean\";\n  if (Array.isArray(val)) return `${inferType(val[0])}[]`;\n  return \"any\";\n}\n\nfunction toCamel(str: string): string {\n  return str\n    .replace(/[-_/](.)/g, (_, c) => c.toUpperCase())\n    .replace(/[^a-zA-Z0-9]/g, \"\")\n    .replace(/^([A-Z])/, (s) => s.toLowerCase());\n}\n\nfunction generateTypeName(pathParts: string[], name: string): string {\n  return pathParts.map(capitalize).join(\"\") + \"Params\";\n}\n\nfunction capitalize(s: string) {\n  return s.charAt(0).toUpperCase() + s.slice(1);\n}\n"
        }
    ]
}