{
    "sourceFile": "src/generator.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 7,
            "patches": [
                {
                    "date": 1750729238454,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1750729565246,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,37 +1,58 @@\n export function generateApiCode(apiSpec: any): string {\n-  const { name, method, endpoint, body } = apiSpec;\n+  const lines: string[] = [];\n \n-  const interfaceName = `${capitalize(name)}Request`;\n-  const bodyFields = Object.entries(body || {})\n-    .map(([key, type]) => `  ${key}: ${mapType(type as string)};`)\n+  function traverse(items: any[], groupNames: string[] = []) {\n+    for (const item of items) {\n+      if (item.item) {\n+        // 중간 그룹\n+        lines.push(`\\n// ${item.name}\\n`);\n+        traverse(item.item, [...groupNames, item.name]);\n+      } else if (item.request?.body?.raw) {\n+        const raw = item.request.body.raw;\n+        let parsed: Record<string, any>;\n \n-    .join(\"\\n\");\n+        try {\n+          parsed = JSON.parse(raw);\n+        } catch {\n+          continue;\n+        }\n \n-  return `\n-interface ${interfaceName} {\n-${bodyFields}\n+        const typeName = generateTypeName(item.request.url?.path || [], item.name);\n+        const fields = Object.entries(parsed)\n+          .map(([key, value]) => `  ${key}: ${inferType(value)};`)\n+          .join(\"\\n\");\n+\n+        lines.push(`export type ${typeName} = {\\n${fields}\\n};\\n`);\n+      }\n+    }\n+  }\n+\n+  traverse(apiSpec.item);\n+\n+  return lines.join(\"\\n\").trim();\n }\n \n-export async function ${name}(data: ${interfaceName}) {\n-  const res = await fetch(\"${endpoint}\", {\n-    method: \"${method}\",\n-    headers: { \"Content-Type\": \"application/json\" },\n-    body: JSON.stringify(data)\n-  });\n-  return await res.json();\n+function inferType(value: any): string {\n+  const type = typeof value;\n+  if (type === \"string\") return \"string\";\n+  if (type === \"number\") return \"number\";\n+  if (type === \"boolean\") return \"boolean\";\n+  if (Array.isArray(value)) return `${inferType(value[0])}[]`;\n+  return \"any\";\n }\n-  `.trim();\n-}\n \n-function mapType(type: string): string {\n-  const map: Record<string, string> = {\n-    string: \"string\",\n-    number: \"number\",\n-    boolean: \"boolean\"\n-  };\n-  return map[type] || \"any\";\n+function generateTypeName(pathParts: string[], name: string): string {\n+  // path 기반 + name 조합\n+  const clean = (s: string) =>\n+    s.replace(/[^a-zA-Z0-9]/g, \" \")\n+      .split(/\\s+/)\n+      .map(capitalize)\n+      .join(\"\");\n+\n+  const base = pathParts.join(\"-\") || name;\n+  return clean(base) + \"Params\";\n }\n \n-function capitalize(s: string) {\n-  return s.charAt(0).toUpperCase() + s.slice(1);\n+function capitalize(str: string): string {\n+  return str.charAt(0).toUpperCase() + str.slice(1);\n }\n"
                },
                {
                    "date": 1750730460834,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,36 @@\n+function capitalize(str: string): string {\n+  return str.charAt(0).toUpperCase() + str.slice(1);\n+}\n+\n+function generateTypeName(pathParts: string[], name: string): string {\n+  const clean = (s: string) =>\n+    s.replace(/[^a-zA-Z0-9]/g, \" \")\n+      .split(/\\s+/)\n+      .map(capitalize)\n+      .join(\"\");\n+\n+  const base = pathParts.join(\"-\") || name;\n+  return clean(base) + \"Params\";\n+}\n+\n+function inferType(value: any): string {\n+  const type = typeof value;\n+  if (type === \"string\") return \"string\";\n+  if (type === \"number\") return \"number\";\n+  if (type === \"boolean\") return \"boolean\";\n+  if (Array.isArray(value)) return `${inferType(value[0])}[]`;\n+  return \"any\";\n+}\n+\n export function generateApiCode(apiSpec: any): string {\n   const lines: string[] = [];\n \n   function traverse(items: any[], groupNames: string[] = []) {\n+    if (!Array.isArray(items)) return;\n+\n     for (const item of items) {\n       if (item.item) {\n-        // 중간 그룹\n         lines.push(`\\n// ${item.name}\\n`);\n         traverse(item.item, [...groupNames, item.name]);\n       } else if (item.request?.body?.raw) {\n         const raw = item.request.body.raw;\n@@ -30,29 +55,4 @@\n   traverse(apiSpec.item);\n \n   return lines.join(\"\\n\").trim();\n }\n-\n-function inferType(value: any): string {\n-  const type = typeof value;\n-  if (type === \"string\") return \"string\";\n-  if (type === \"number\") return \"number\";\n-  if (type === \"boolean\") return \"boolean\";\n-  if (Array.isArray(value)) return `${inferType(value[0])}[]`;\n-  return \"any\";\n-}\n-\n-function generateTypeName(pathParts: string[], name: string): string {\n-  // path 기반 + name 조합\n-  const clean = (s: string) =>\n-    s.replace(/[^a-zA-Z0-9]/g, \" \")\n-      .split(/\\s+/)\n-      .map(capitalize)\n-      .join(\"\");\n-\n-  const base = pathParts.join(\"-\") || name;\n-  return clean(base) + \"Params\";\n-}\n-\n-function capitalize(str: string): string {\n-  return str.charAt(0).toUpperCase() + str.slice(1);\n-}\n"
                },
                {
                    "date": 1750811614815,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,8 +21,36 @@\n   if (Array.isArray(value)) return `${inferType(value[0])}[]`;\n   return \"any\";\n }\n \n+function parseRawJsonWithComments(raw: string): Record<string, { value: any; optional: boolean }> {\n+  const result: Record<string, { value: any; optional: boolean }> = {};\n+  const lines = raw.split(\"\\n\");\n+\n+  for (const line of lines) {\n+    const match = line.match(/\"(.+?)\"\\s*:\\s*(.+?)(\\s*\\/\\/\\s*(.*))?$/);\n+    if (!match) continue;\n+\n+    const [, key, rawValue, , comment] = match;\n+    let value: any;\n+    try {\n+      value = JSON.parse(rawValue.endsWith(\",\") ? rawValue.slice(0, -1) : rawValue);\n+    } catch {\n+      value = rawValue.trim().replace(/,$/, \"\");\n+    }\n+\n+    const optional = comment?.trim() === \"?\";\n+    result[key] = { value, optional };\n+  }\n+\n+  return result;\n+}\n+\n+function inferTypeWithOptional(value: any, optional: boolean): string {\n+  const baseType = inferType(value);\n+  return optional ? `${baseType} | null` : baseType;\n+}\n+\n export function generateApiCode(apiSpec: any): string {\n   const lines: string[] = [];\n \n   function traverse(items: any[], groupNames: string[] = []) {\n@@ -33,26 +61,27 @@\n         lines.push(`\\n// ${item.name}\\n`);\n         traverse(item.item, [...groupNames, item.name]);\n       } else if (item.request?.body?.raw) {\n         const raw = item.request.body.raw;\n-        let parsed: Record<string, any>;\n+        let parsed: Record<string, { value: any; optional: boolean }>;\n \n         try {\n-          parsed = JSON.parse(raw);\n+          parsed = parseRawJsonWithComments(raw);\n         } catch {\n           continue;\n         }\n \n         const typeName = generateTypeName(item.request.url?.path || [], item.name);\n         const fields = Object.entries(parsed)\n-          .map(([key, value]) => `  ${key}: ${inferType(value)};`)\n+          .map(([key, { value, optional }]) =>\n+            `  ${key}${optional ? \"?\" : \"\"}: ${inferTypeWithOptional(value, optional)};`\n+          )\n           .join(\"\\n\");\n \n         lines.push(`export type ${typeName} = {\\n${fields}\\n};\\n`);\n       }\n     }\n   }\n \n   traverse(apiSpec.item);\n-\n   return lines.join(\"\\n\").trim();\n }\n"
                },
                {
                    "date": 1750923823892,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,16 +13,31 @@\n   return clean(base) + \"Params\";\n }\n \n function inferType(value: any): string {\n-  const type = typeof value;\n-  if (type === \"string\") return \"string\";\n-  if (type === \"number\") return \"number\";\n-  if (type === \"boolean\") return \"boolean\";\n-  if (Array.isArray(value)) return `${inferType(value[0])}[]`;\n-  return \"any\";\n+  if (value === null) return \"null\";\n+\n+  if (Array.isArray(value)) {\n+    if (value.length === 0) return \"any[]\";\n+    return `${inferType(value[0])}[]`;\n+  }\n+\n+  if (typeof value === \"object\") {\n+    const fields = Object.entries(value)\n+      .map(([key, val]) => `${key}: ${inferType(val)}`)\n+      .join(\"; \");\n+    return `{ ${fields} }`;\n+  }\n+\n+  if (typeof value === \"string\") {\n+    if (value === \"ASC\" || value === \"DESC\") return `\"ASC\" | \"DESC\" | null`;\n+    return \"string\";\n+  }\n+\n+  return typeof value;\n }\n \n+\n function parseRawJsonWithComments(raw: string): Record<string, { value: any; optional: boolean }> {\n   const result: Record<string, { value: any; optional: boolean }> = {};\n   const lines = raw.split(\"\\n\");\n \n"
                },
                {
                    "date": 1750923888858,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,83 @@\n+function capitalize(str: string): string {\n+  return str.charAt(0).toUpperCase() + str.slice(1);\n+}\n+\n+function generateTypeName(pathParts: string[], name: string): string {\n+  const clean = (s: string) =>\n+    s.replace(/[^a-zA-Z0-9]/g, \" \")\n+      .split(/\\s+/)\n+      .map(capitalize)\n+      .join(\"\");\n+\n+  const base = pathParts.join(\"-\") || name;\n+  return clean(base) + \"Params\";\n+}\n+\n+function inferType(value: any): string {\n+  if (value === null) return \"null\";\n+\n+  if (Array.isArray(value)) {\n+    if (value.length === 0) return \"any[]\";\n+    return `${inferType(value[0])}[]`;\n+  }\n+\n+  if (typeof value === \"object\") {\n+    const fields = Object.entries(value)\n+      .map(([key, val]) => `${key}: ${inferType(val)}`)\n+      .join(\"; \");\n+    return `{ ${fields} }`;\n+  }\n+\n+  if (typeof value === \"string\") {\n+    if (value === \"ASC\" || value === \"DESC\") return `\"ASC\" | \"DESC\" | null`;\n+    return \"string\";\n+  }\n+\n+  return typeof value;\n+}\n+\n+function parseRawJson(raw: string): any {\n+  try {\n+    return JSON.parse(raw);\n+  } catch (e) {\n+    return null;\n+  }\n+}\n+\n+function inferTypeWithOptional(value: any, optional: boolean): string {\n+  const baseType = inferType(value);\n+  return optional ? `${baseType} | null` : baseType;\n+}\n+\n+export function generateApiCode(apiSpec: any): string {\n+  const lines: string[] = [];\n+\n+  function traverse(items: any[], groupNames: string[] = []) {\n+    if (!Array.isArray(items)) return;\n+\n+    for (const item of items) {\n+      if (item.item) {\n+        lines.push(`\\n// ${item.name}\\n`);\n+        traverse(item.item, [...groupNames, item.name]);\n+      } else if (item.request?.body?.raw) {\n+        const raw = item.request.body.raw;\n+        const parsedObj = parseRawJson(raw);\n+        if (!parsedObj || typeof parsedObj !== \"object\") continue;\n+\n+        const typeName = generateTypeName(item.request.url?.path || [], item.name);\n+\n+        const fields = Object.entries(parsedObj)\n+          .map(([key, val]) => {\n+            const optional = false; // raw에 주석 없으므로 기본은 필수\n+            return `  ${key}${optional ? \"?\" : \"\"}: ${inferTypeWithOptional(val, optional)};`;\n+          })\n+          .join(\"\\n\");\n+\n+        lines.push(`export type ${typeName} = {\\n${fields}\\n};\\n`);\n+      }\n+    }\n+  }\n+\n+  traverse(apiSpec.item);\n+  return lines.join(\"\\n\").trim();\n+}\n"
                },
                {
                    "date": 1750923992399,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,38 +13,39 @@\n   return clean(base) + \"Params\";\n }\n \n function inferType(value: any): string {\n-  if (value === null) return \"null\";\n+  const type = typeof value;\n+  if (type === \"string\") return \"string\";\n+  if (type === \"number\") return \"number\";\n+  if (type === \"boolean\") return \"boolean\";\n+  if (Array.isArray(value)) return `${inferType(value[0])}[]`;\n+  return \"any\";\n+}\n \n-  if (Array.isArray(value)) {\n-    if (value.length === 0) return \"any[]\";\n-    return `${inferType(value[0])}[]`;\n-  }\n+function parseRawJsonWithComments(raw: string): Record<string, { value: any; optional: boolean }> {\n+  const result: Record<string, { value: any; optional: boolean }> = {};\n+  const lines = raw.split(\"\\n\");\n \n-  if (typeof value === \"object\") {\n-    const fields = Object.entries(value)\n-      .map(([key, val]) => `${key}: ${inferType(val)}`)\n-      .join(\"; \");\n-    return `{ ${fields} }`;\n-  }\n+  for (const line of lines) {\n+    const match = line.match(/\"(.+?)\"\\s*:\\s*(.+?)(\\s*\\/\\/\\s*(.*))?$/);\n+    if (!match) continue;\n \n-  if (typeof value === \"string\") {\n-    if (value === \"ASC\" || value === \"DESC\") return `\"ASC\" | \"DESC\" | null`;\n-    return \"string\";\n+    const [, key, rawValue, , comment] = match;\n+    let value: any;\n+    try {\n+      value = JSON.parse(rawValue.endsWith(\",\") ? rawValue.slice(0, -1) : rawValue);\n+    } catch {\n+      value = rawValue.trim().replace(/,$/, \"\");\n+    }\n+\n+    const optional = comment?.trim() === \"?\";\n+    result[key] = { value, optional };\n   }\n \n-  return typeof value;\n+  return result;\n }\n \n-function parseRawJson(raw: string): any {\n-  try {\n-    return JSON.parse(raw);\n-  } catch (e) {\n-    return null;\n-  }\n-}\n-\n function inferTypeWithOptional(value: any, optional: boolean): string {\n   const baseType = inferType(value);\n   return optional ? `${baseType} | null` : baseType;\n }\n@@ -60,18 +61,21 @@\n         lines.push(`\\n// ${item.name}\\n`);\n         traverse(item.item, [...groupNames, item.name]);\n       } else if (item.request?.body?.raw) {\n         const raw = item.request.body.raw;\n-        const parsedObj = parseRawJson(raw);\n-        if (!parsedObj || typeof parsedObj !== \"object\") continue;\n+        let parsed: Record<string, { value: any; optional: boolean }>;\n \n+        try {\n+          parsed = parseRawJsonWithComments(raw);\n+        } catch {\n+          continue;\n+        }\n+\n         const typeName = generateTypeName(item.request.url?.path || [], item.name);\n-\n-        const fields = Object.entries(parsedObj)\n-          .map(([key, val]) => {\n-            const optional = false; // raw에 주석 없으므로 기본은 필수\n-            return `  ${key}${optional ? \"?\" : \"\"}: ${inferTypeWithOptional(val, optional)};`;\n-          })\n+        const fields = Object.entries(parsed)\n+          .map(([key, { value, optional }]) =>\n+            `  ${key}${optional ? \"?\" : \"\"}: ${inferTypeWithOptional(value, optional)};`\n+          )\n           .join(\"\\n\");\n \n         lines.push(`export type ${typeName} = {\\n${fields}\\n};\\n`);\n       }\n"
                },
                {
                    "date": 1750924071920,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -13,141 +13,47 @@\n   return clean(base) + \"Params\";\n }\n \n function inferType(value: any): string {\n+  if (Array.isArray(value)) {\n+    if (value.length === 0) return \"any[]\";\n+    return `${inferType(value[0])}[]`;\n+  }\n+  if (value === null) return \"any\";\n   const type = typeof value;\n   if (type === \"string\") return \"string\";\n   if (type === \"number\") return \"number\";\n   if (type === \"boolean\") return \"boolean\";\n-  if (Array.isArray(value)) return `${inferType(value[0])}[]`;\n+  if (type === \"object\") return \"{ \" + Object.entries(value)\n+    .map(([k, v]) => `${k}: ${inferType(v)}`)\n+    .join(\"; \") + \" }\";\n   return \"any\";\n }\n \n function parseRawJsonWithComments(raw: string): Record<string, { value: any; optional: boolean }> {\n-  const result: Record<string, { value: any; optional: boolean }> = {};\n-  const lines = raw.split(\"\\n\");\n-\n-  for (const line of lines) {\n-    const match = line.match(/\"(.+?)\"\\s*:\\s*(.+?)(\\s*\\/\\/\\s*(.*))?$/);\n-    if (!match) continue;\n-\n-    const [, key, rawValue, , comment] = match;\n-    let value: any;\n-    try {\n-      value = JSON.parse(rawValue.endsWith(\",\") ? rawValue.slice(0, -1) : rawValue);\n-    } catch {\n-      value = rawValue.trim().replace(/,$/, \"\");\n-    }\n-\n-    const optional = comment?.trim() === \"?\";\n-    result[key] = { value, optional };\n+  let json: any;\n+  try {\n+    // 주석 제거\n+    const cleaned = raw.replace(/\\/\\/.*$/gm, \"\");\n+    json = JSON.parse(cleaned);\n+  } catch {\n+    return {};\n   }\n \n-  return result;\n-}\n-\n-function inferTypeWithOptional(value: any, optional: boolean): string {\n-  const baseType = inferType(value);\n-  return optional ? `${baseType} | null` : baseType;\n-}\n-\n-export function generateApiCode(apiSpec: any): string {\n-  const lines: string[] = [];\n-\n-  function traverse(items: any[], groupNames: string[] = []) {\n-    if (!Array.isArray(items)) return;\n-\n-    for (const item of items) {\n-      if (item.item) {\n-        lines.push(`\\n// ${item.name}\\n`);\n-        traverse(item.item, [...groupNames, item.name]);\n-      } else if (item.request?.body?.raw) {\n-        const raw = item.request.body.raw;\n-        let parsed: Record<string, { value: any; optional: boolean }>;\n-\n-        try {\n-          parsed = parseRawJsonWithComments(raw);\n-        } catch {\n-          continue;\n-        }\n-\n-        const typeName = generateTypeName(item.request.url?.path || [], item.name);\n-        const fields = Object.entries(parsed)\n-          .map(([key, { value, optional }]) =>\n-            `  ${key}${optional ? \"?\" : \"\"}: ${inferTypeWithOptional(value, optional)};`\n-          )\n-          .join(\"\\n\");\n-\n-        lines.push(`export type ${typeName} = {\\n${fields}\\n};\\n`);\n-      }\n+  function walk(obj: any): Record<string, { value: any; optional: boolean }> {\n+    const result: Record<string, { value: any; optional: boolean }> = {};\n+    for (const key in obj) {\n+      const value = obj[key];\n+      // 옵션 여부는 주석에서 추출하는 대신, 값이 undefined면 optional로 처리\n+      const optional = false;\n+      result[key] = { value, optional };\n     }\n+    return result;\n   }\n \n-  traverse(apiSpec.item);\n-  return lines.join(\"\\n\").trim();\n+  return walk(json);\n }\n-function capitalize(str: string): string {\n-  return str.charAt(0).toUpperCase() + str.slice(1);\n-}\n \n-function generateTypeName(pathParts: string[], name: string): string {\n-  const clean = (s: string) =>\n-    s.replace(/[^a-zA-Z0-9]/g, \" \")\n-      .split(/\\s+/)\n-      .map(capitalize)\n-      .join(\"\");\n-\n-  const base = pathParts.join(\"-\") || name;\n-  return clean(base) + \"Params\";\n-}\n-\n-function inferType(value: any): string {\n-  if (value === null) return \"null\";\n-\n-  if (Array.isArray(value)) {\n-    if (value.length === 0) return \"any[]\";\n-    return `${inferType(value[0])}[]`;\n-  }\n-\n-  if (typeof value === \"object\") {\n-    const fields = Object.entries(value)\n-      .map(([key, val]) => `${key}: ${inferType(val)}`)\n-      .join(\"; \");\n-    return `{ ${fields} }`;\n-  }\n-\n-  if (typeof value === \"string\") {\n-    if (value === \"ASC\" || value === \"DESC\") return `\"ASC\" | \"DESC\" | null`;\n-    return \"string\";\n-  }\n-\n-  return typeof value;\n-}\n-\n-\n-function parseRawJsonWithComments(raw: string): Record<string, { value: any; optional: boolean }> {\n-  const result: Record<string, { value: any; optional: boolean }> = {};\n-  const lines = raw.split(\"\\n\");\n-\n-  for (const line of lines) {\n-    const match = line.match(/\"(.+?)\"\\s*:\\s*(.+?)(\\s*\\/\\/\\s*(.*))?$/);\n-    if (!match) continue;\n-\n-    const [, key, rawValue, , comment] = match;\n-    let value: any;\n-    try {\n-      value = JSON.parse(rawValue.endsWith(\",\") ? rawValue.slice(0, -1) : rawValue);\n-    } catch {\n-      value = rawValue.trim().replace(/,$/, \"\");\n-    }\n-\n-    const optional = comment?.trim() === \"?\";\n-    result[key] = { value, optional };\n-  }\n-\n-  return result;\n-}\n-\n function inferTypeWithOptional(value: any, optional: boolean): string {\n   const baseType = inferType(value);\n   return optional ? `${baseType} | null` : baseType;\n }\n"
                }
            ],
            "date": 1750729238454,
            "name": "Commit-0",
            "content": "export function generateApiCode(apiSpec: any): string {\n  const { name, method, endpoint, body } = apiSpec;\n\n  const interfaceName = `${capitalize(name)}Request`;\n  const bodyFields = Object.entries(body || {})\n    .map(([key, type]) => `  ${key}: ${mapType(type as string)};`)\n\n    .join(\"\\n\");\n\n  return `\ninterface ${interfaceName} {\n${bodyFields}\n}\n\nexport async function ${name}(data: ${interfaceName}) {\n  const res = await fetch(\"${endpoint}\", {\n    method: \"${method}\",\n    headers: { \"Content-Type\": \"application/json\" },\n    body: JSON.stringify(data)\n  });\n  return await res.json();\n}\n  `.trim();\n}\n\nfunction mapType(type: string): string {\n  const map: Record<string, string> = {\n    string: \"string\",\n    number: \"number\",\n    boolean: \"boolean\"\n  };\n  return map[type] || \"any\";\n}\n\nfunction capitalize(s: string) {\n  return s.charAt(0).toUpperCase() + s.slice(1);\n}\n"
        }
    ]
}